#-------------------------------------------------------------------------------
# Name:        drone_bb_test.py
# Purpose:
#
# Author:      Mattia Gramuglia
#
# Created:     4/25/2023       
#-------------------------------------------------------------------------------

#%% Inizialization of the code

def main():
    pass

if __name__ == '__main__':
    main()


import os
import math
import time
import datetime
import sys, getopt
import pychrono as chrono
import pychrono.postprocess as postprocess
import pychrono.irrlicht as irr
import pytz
import csv

import matplotlib.pyplot as plt
import numpy as np
from numpy import linalg as LA
import scipy
from scipy import linalg

from functions import chvector_to_list, chquaternion_to_list, chcoordsys_to_list
from functions import chmatrix33_to_list, list_to_array, rotmat_fromQ_Glob_to_Loc_asarray
from functions import rotmat_fromQ_Glob_to_Loc_asChMatrix33, euler321_fromQ_asChVector
from functions import rotmat_from_euler321, rad2deg, MyReportContactCallback
from functions import PIDcontroller, euler321_from_rotmat, euler321_from_rotmat_matlab, euler321_from_rotmat_matlab_opposite_direction
from functions import rk4singlestep, series_element, find_s

from trajectory import (circular_trajectory, hover_trajectory, square_trajectory,
                        roundedRectangle_trajectory, piecewisePolynomial_trajectory)
from GainsController import Gains



PI = math.pi

# ---------------------------------------------------------------------
#%%The main wrapper function starts!-------------------------------------------------------------------------------------------------------
def WrapperMain_function(target_folder, controller_type, wrapper_control_parameters, wrapper_foldername, wrapper_filename, max_simulation_time, csv_file_path_abnormalities, Wrapper_execution, visualization_flag):
    print("Wrapper loop starts here")
    global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
    global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
    global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
    global mu_PD_baseline_tran, Moment_baseline_PI, e_tran, integral_eQe_tran, e_rot, integral_eQe_rot
    global epsilon_tran, integral_epsQeps_tran, epsilon_rot, integral_epsQeps_rot, e_transient_tran
    global integral_etQet_tran, e_transient_rot, integral_etQet_rot, omega_ref_dot, omega_cmd, omega_cmd_dot
    global Jacobian_matrix, Jacobian_matrix_dot, angular_error

    #%% File settings
    
    # Parse command-line parameters
    
    m_filename = "drone_bb.py"
    m_timestep = 0.005 #0.005 - 0.01
    m_length = 1.0
    m_visualization = "irrlicht"
    # m_datapath = "C:/workspace/chrono/data/"  # change this accordingly to where you saved chrono data
    m_datapath = "C:/ProgramData/Anaconda/envs/chrono/Library/data/"  # change this accordingly to where you saved chrono data
    
    # m_filename_env = os.getcwd() + "/environments/environment3.py"
    m_filename_env = os.getcwd() + "/environments/environmentA.py"

    #%% Importing bodies and constraints from the solidworks generated file
    
    # ----------------------------------------------------------------
    #                     INCLUDE ENVIRONMENT
    # ----------------------------------------------------------------
    
    # environment_included = True
    
    environment_included = False
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------
    
    #  load the file generated by the SolidWorks CAD plugin
    #  and add it to the ChSystem.
    
    # Remove the trailing .py and add / in case of file without ./
    m_absfilename = os.path.abspath(m_filename)
    m_modulename = os.path.splitext(m_absfilename)[0]
    
    exported_items = chrono.ImportSolidWorksSystem(m_modulename)
    
    # Print exported items
    for my_item in exported_items:
    	print (my_item.GetName())
    
    # Add items to the physical system
    my_system = chrono.ChSystemNSC()
    for my_item in exported_items:
    	my_system.Add(my_item)
    
    if environment_included == True:
    
        # Remove the trailing .py and add / in case of file without ./
        m_absfilename_env = os.path.abspath(m_filename_env)
        m_modulename_env = os.path.splitext(m_absfilename_env)[0]
        
        exported_items_env = chrono.ImportSolidWorksSystem(m_modulename_env)
        
        # Print exported items
        for my_item_env in exported_items_env:
        	print (my_item_env.GetName())
         # Add items to the physical system
        	my_system.Add(my_item_env)
        
        # Assigning names to the bodies imported from solidworks and checking if they are found
        my_environment = my_system.SearchBody('environment1-1')
        my_environment = my_system.SearchBody('environmentA-1')
        if my_environment :
            print('Environment found!')
        if not my_environment :
            sys.exit('Error: cannot find Environment from its name in the C::E system!')
            
   #%% Defining Wrapper control parameters and creating folders and files            
    if Wrapper_execution == True:		
        folder_path = os.path.join(target_folder, wrapper_foldername)
    
        # Create the folder if it doesn't exist
        if not os.path.exists(folder_path):
            os.mkdir(folder_path)
            print(f"Folder '{wrapper_foldername}' created successfully.")
        
        wrapper_filename_csv = wrapper_filename  + ".csv"
        csv_file_path = os.path.join(folder_path, wrapper_filename_csv)
        
        
        #Wrapper parameters passed-------------------------------------
    my_ball_density = wrapper_control_parameters["my_ball_density"]
    		
    #%% Solver parameters
    
    #my_system.SetMaxPenetrationRecoverySpeed(1.00)
    # my_solver = chrono.ChSolverBB() # default solver set by the solidworks pychrono module
    my_solver = chrono.ChSolverPSOR() # same solver as 'demo_MBS_collisionNSC'
    my_system.SetSolver(my_solver)
    my_solver.SetMaxIterations(1000) #600 #1000
    my_solver.EnableWarmStart(True)
    
    chrono.ChCollisionModel.SetDefaultSuggestedEnvelope(0.001) #0.003 #0.001
    chrono.ChCollisionModel.SetDefaultSuggestedMargin(0.0005) #0.003 #0.0005
    chrono.ChCollisionSystemBullet.SetContactBreakingThreshold(0.001) #0.002 #0.001

    #%% System and General parameters
    
    G_acc = 9.80665 # Gravitational acceleration
    my_system.Set_G_acc(chrono.ChVectorD(0,-G_acc,0))
    # my_system.Set_G_acc(chrono.ChVectorD(0,0,0)) # No Gravity
    position_local_pixhawk = chrono.ChVectorD(0.0293, 0.04925, 0) # position of the "pixhawk's center" wrt local frame
    position_pixhawk_fromCOG = chrono.ChVectorD(-0.0214807964657055, 0.0779592340719906, -0.0000487571767365452) # position of the "pixhawk's center" wrt the COG of the drone frame
    global_coord = chrono.ChCoordsysD(chrono.ChVectorD(0,0,0), chrono.ChQuaternionD(1,0,0,0)) # Global reference frame
    pixhawk_csys = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)) # Coordinate System Pixhawk
    
    pixhawk_csys_fixed = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0))# Coordinate System as Pixhawk convention but fixed to ground
    
    force_1_5_pos = chrono.ChVectorD(-0.08760601358, -0.0085, -0.10859150436) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 1 & 5
    force_2_6_pos = chrono.ChVectorD(0.08812691616, -0.0085, -0.10834502049) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 2 & 6
    force_3_7_pos = chrono.ChVectorD(0.08760601358, -0.0085, 0.10859150436) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 3 & 7
    force_4_8_pos = chrono.ChVectorD(-0.08812691616, -0.0085, 0.10834502049) # position wrt local frame of where to apply the thrust force generated by the motors'couple identified by number 4 & 8
    
    # Rotation Matrix that represents a fixed rotation of PI/2 rad around the X-Axis
    RotMat_X_PI_2_list = [[1,  0,  0],
                          [0,  0,  1],
                          [0, -1,  0]]
    
    # RotMat_X_PI_2 = chrono.ChMatrix33D()
    # RotMat_X_PI_2.SetMatr(RotMat_X_PI_2_list)
    RotMat_X_PI_2_array = np.array(RotMat_X_PI_2_list)
    
    # Rotation Matrix that represents a fixed rotation of -PI/2 rad around the X-Axis
    RotMat_X_PI_2_tran_array = np.transpose(RotMat_X_PI_2_array)
    
    # Inertia matrix of the system: (drone frame + box + propellers) espressed in Solidworks coordinate sys (x-front, y-up, z-right), computed at the center of mass
    Inertia_mat_sw = np.array([[ 0.0227199027,  0.0010034978, -0.0000065570],
                               [ 0.0010034978,  0.0161469360, -0.0000056584],
                               [-0.0000065570, -0.0000056584,  0.0220204718]])
    
    # Inertia matrix of the system: (drone frame + box + propellers) espressed in Pixhawk coordinate sys (x-front, y-right, z-down), computed at the center of mass
    Inertia_mat_pixhawk = np.matmul(RotMat_X_PI_2_array, np.matmul(Inertia_mat_sw, RotMat_X_PI_2_tran_array))
    
    air_density = 1.225 # Air density [kg/m^3]
    surface_area = 0.07 # Surface area of the drone to account for drag [m^2]
    drag_coefficient = 1.28 # Drag coefficient (equal to that of a plate) [-]
    drag_coefficient_matrix = np.matrix(np.diag([drag_coefficient,drag_coefficient,0]))
    
    
    
    #%% Assigning names to the bodies imported from solidworks and checking if they are found
    
    my_ground = my_system.SearchBody('ground')
    if my_ground :
        print('Ground found!')
    if not my_ground :
        sys.exit('Error: cannot find ground from its name in the C::E system!')
    
    my_frame = my_system.SearchBody('drone_big_box-1')
    if my_frame :
        print('Frame found!')
    if not my_frame :
        sys.exit('Error: cannot find drone frame  from its name in the C::E system!')
     
    my_box = my_system.SearchBody('box_big_200x200x100-1')
    if my_box :
        print('Box found!')
    if not my_box :
        sys.exit('Error: cannot find box from its name in the C::E system!')
        
    my_prop1 = my_system.SearchBody('3_blade_prop-1')
    if my_prop1 :
        print('Propeller_1 found!')
    if not my_prop1 :
        sys.exit('Error: cannot find Propeller_1 from its name in the C::E system!')
        
    my_prop2 = my_system.SearchBody('3_blade_prop-2')
    if my_prop2 :
        print('Propeller_2 found!')
    if not my_prop2 :
        sys.exit('Error: cannot find Propeller_2 from its name in the C::E system!')
        
    my_prop3 = my_system.SearchBody('3_blade_prop-3')
    if my_prop3 :
        print('Propeller_3 found!')
    if not my_prop3 :
        sys.exit('Error: cannot find Propeller_3 from its name in the C::E system!')
        
    my_prop4 = my_system.SearchBody('3_blade_prop-4')
    if my_prop4 :
        print('Propeller_4 found!')
    if not my_prop4 :
        sys.exit('Error: cannot find Propeller_4 from its name in the C::E system!')
        
    my_prop5 = my_system.SearchBody('3_blade_prop-5')
    if my_prop5 :
        print('Propeller_5 found!')
    if not my_prop5 :
        sys.exit('Error: cannot find Propeller_5 from its name in the C::E system!')
        
    my_prop6 = my_system.SearchBody('3_blade_prop-6')
    if my_prop6 :
        print('Propeller_6 found!')
    if not my_prop6 :
        sys.exit('Error: cannot find Propeller_6 from its name in the C::E system!')
        
    my_prop7 = my_system.SearchBody('3_blade_prop-7')
    if my_prop7 :
        print('Propeller_7 found!')
    if not my_prop7 :
        sys.exit('Error: cannot find Propeller_7 from its name in the C::E system!')
        
    my_prop8 = my_system.SearchBody('3_blade_prop-8')
    if my_prop8 :
        print('Propeller_8 found!')
    if not my_prop8 :
        sys.exit('Error: cannot find Propeller_8 from its name in the C::E system!')
        
    # Assigning names to the Coordinate Systems/Markers imported from solidworks and checking if they are found
    my_marker1 = my_system.SearchMarker('Coordinate System1')
    if my_marker1 :
        print('Marker_1 found!')
    if not my_marker1 :
        sys.exit('Error: cannot find marker1 from its name in the C::E system!')
        
    my_marker2 = my_system.SearchMarker('Coordinate System2')
    if my_marker2 :
        print('Marker_2 found!')
    if not my_marker2 :
        sys.exit('Error: cannot find marker2 from its name in the C::E system!')
        
    my_marker3 = my_system.SearchMarker('Coordinate System3')
    if my_marker3 :
        print('Marker_3 found!')
    if not my_marker3 :
        sys.exit('Error: cannot find marker3 from its name in the C::E system!')
        
    my_marker4 = my_system.SearchMarker('Coordinate System4')
    if my_marker4 :
        print('Marker_4 found!')
    if not my_marker4 :
        sys.exit('Error: cannot find marker4 from its name in the C::E system!')
        
    my_marker5 = my_system.SearchMarker('Coordinate System5')
    if my_marker5 :
        print('Marker_5 found!')
    if not my_marker5 :
        sys.exit('Error: cannot find marker5 from its name in the C::E system!')
        
    my_marker6 = my_system.SearchMarker('Coordinate System6')
    if my_marker6 :
        print('Marker_6 found!')
    if not my_marker6 :
        sys.exit('Error: cannot find marker6 from its name in the C::E system!')
        
    my_marker7 = my_system.SearchMarker('Coordinate System7')
    if my_marker7 :
        print('Marker_7 found!')
    if not my_marker7 :
        sys.exit('Error: cannot find marker7 from its name in the C::E system!')
        
    my_marker8 = my_system.SearchMarker('Coordinate System8')
    if my_marker8 :
        print('Marker_8 found!')
    if not my_marker8 :
        sys.exit('Error: cannot find marker8 from its name in the C::E system!')   
        
    
    
    #%% Create bodies and floor
    
    # Create contact materials and set their properties
    contact_material_floor = chrono.ChMaterialSurfaceNSC()
    contact_material_floor.SetFriction(1) # 1
    contact_material_floor.SetDampingF(0.5) # 0.5
    contact_material_ball = chrono.ChMaterialSurfaceNSC()
    # contact_material_ball.SetFriction(2) # 0.01
    # contact_material_ball.SetRollingFriction(1) # 0.03
    # contact_material_ball.SetSpinningFriction(1) # 0.03
    # contact_material_ball.SetDampingF(0.1) # 1
    
     
    # Create a floor
    mfloor = chrono.ChBodyEasyBox(50, 0.1, 50, 1000,True,True, contact_material_floor)
    mfloor.SetName('Floor')
    mfloor.SetBodyFixed(True)
    mfloor_Yposition = 0.3
    mfloor.SetPos(chrono.ChVectorD(0,-mfloor_Yposition,0))
    # mfloor.SetPos(chrono.ChVectorD(0,-0.5,0))
    mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/light_gray.png"))
    # mfloor.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/concrete.jpg"))
    # mfloor.GetVisualShape(0).SetColor(chrono.ChColor(1, 1, 1))
    my_system.Add(mfloor)
    
    my_ball1 = chrono.ChBodyEasySphere(0.0254,      # radius size # 0.0254 - 0.01905 - 0.015875
                                          my_ball_density,     # density 7850
                                          True,     # visualization?
                                          True,     # collision?
                                          contact_material_ball)  # contact material
    my_ball1.SetName('Ball_1')
    my_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0.065)) # -0.05,-0.15,0
    # my_ball1.SetPos(chrono.ChVectorD(-0.05,-0.15,0))
    my_ball1.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))
    # my_ball1.GetVisualShape(0).SetColor(chrono.ChColor(0, 1, 0))
    my_system.Add(my_ball1)
    
    # my_ball1.SetPos_dt(chrono.ChVectorD(0,0,10))
    
    my_ball2 = chrono.ChBodyEasySphere(0.0254,      # radius size
                                          my_ball_density,     # density 7850
                                          True,     # visualization?
                                          True,     # collision?
                                          contact_material_ball)  # contact material
    my_ball2.SetName('Ball_2')
    my_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0.065))
    # my_ball2.SetPos(chrono.ChVectorD(0.05,-0.15,0))
    my_ball2.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker2.png"))
    # my_ball2.GetVisualShape(0).SetColor(chrono.ChColor(0, 0, 1))
    my_system.Add(my_ball2)
    
    # my_ball2.SetWvel_loc(chrono.ChVectorD(0,0,5))
    # my_ball2.SetPos_dt(chrono.ChVectorD(0,1,0))
    
    #%% Additional bodies
    # for bi in range(20):
    #     my_ball3 = chrono.ChBodyEasySphere(0.015875,      # radius size
    #                                           7850,     # density 7850
    #                                           True,     # visualization?
    #                                           True,     # collision?
    #                                           contact_material_ball)  # contact material
    #     my_ball3.SetName('Ball_3')
    #     my_ball3.SetPos(chrono.ChVectorD(-0.05 + chrono.ChRandom() * 0.1,-0.2 + chrono.ChRandom() * 0.05, -0.05 + chrono.ChRandom() * 0.1))
    #     my_ball3.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/checker1.png"))
    #     my_system.Add(my_ball3)

    #========================================================================================================================================
    # # Adding multiple balls    
    # def create_and_add_sphere_body(index, system, radius, density, visualize=True, collision=True, contact_material=None):
    #     sphere_body = chrono.ChBodyEasySphere(radius, density, visualize, collision, contact_material)
    #     sphere_body.SetName('Ball_3_{}'.format(index))  # Add a random number to the name
    #     sphere_body.SetPos(chrono.ChVectorD(
    #         # -0.05 + chrono.ChRandom() * 0.1,
    #         # -0.2 + chrono.ChRandom() * 0.05,
    #         # -0.05 + chrono.ChRandom() * 0.1
    #         -0.05 + 0.035 * index * (index<5) + 0.035 * (index-5) * (index>=5),
    #         -0.2,
    #         -0.05+ 0.1 * (index>=5)
    #     ))
    #     sphere_body.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/redwhite.png"))
    #     system.Add(sphere_body)  # Add the sphere body to the provided system
    #     return sphere_body
    
    # # my_ball3_1 = create_and_add_sphere_body(1, my_system, 0.015875, 7850, True, True, contact_material_ball)
    # # my_ball3_2 = create_and_add_sphere_body(2, my_system, 0.015875, 7850, True, True, contact_material_ball)
    
    # for i in range(0, 10):
    #     variable_name = f'my_ball3_{i}'  # Construct the variable name
    #     globals()[variable_name] = create_and_add_sphere_body(i, my_system, 0.015875, my_ball_density, True, True, contact_material_ball)
    #========================================================================================================================================
        
    # print('Ball 3 mass in kg: ',my_ball3.GetMass())
    
    # my_ball4 = chrono.ChBodyEasySphere(0.015875,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball4.SetName('Ball_4')
    # my_ball4.SetPos(force_4_8_pos)
    # my_ball4.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/blue.png"))
    # my_system.Add(my_ball4)
    
    # my_ball4.SetBodyFixed(True)
    
    # my_ball4 = chrono.ChBodyEasySphere(0.02,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball4.SetName('Ball_4')
    # # my_ball4.SetPos(chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05)) # my_COG_local
    # my_ball4.SetPos(chrono.ChVectorD(0.0063298425197185135, -0.057308727962443, -3.9465411906584656e-05)) # COG
    # # my_ball4.SetPos(chrono.ChVectorD(0,0,0))
    # my_ball4.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/blue.png"))
    # my_system.Add(my_ball4)
    
    # my_ball4.SetBodyFixed(True)
    
    # my_ball5 = chrono.ChBodyEasySphere(0.0254,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball5.SetName('Ball_5')
    # my_ball5.SetPos(chrono.ChVectorD(-0.75,-0.1,0))
    # my_ball5.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/pink.png"))
    # my_system.Add(my_ball5)
    # # print('Ball 1 mass in kg: ',my_ball1.GetMass())
    
    # my_ball6 = chrono.ChBodyEasySphere(0.0254,      # radius size
    #                                       7850,     # density 7850
    #                                       True,     # visualization?
    #                                       True,     # collision?
    #                                       contact_material_ball)  # contact material
    # my_ball6.SetName('Ball_6')
    # my_ball6.SetPos(position_local_pixhawk)
    # my_ball6.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/blue.png"))
    # # my_ball6.SetBodyFixed(True)
    # my_system.Add(my_ball6)
    
    
    # body_A= chrono.ChBodyEasyBox(1, 1, 1, 1000,True,True, contact_material_ball)                              
    # body_A.SetPos(chrono.ChVectorD(0,1,0))
    # # body_A.SetRot(chrono.ChQuaternionD(0.3827,0.9239,0,0))
    # body_A.SetRot(chrono.ChQuaternionD(0.2588,0.9659,0,0))
    # body_A.GetVisualShape(0).SetTexture(chrono.GetChronoDataFile("textures/pink.png"))
    # my_system.Add(body_A)
    
    # my_frame.SetBodyFixed(True)

    #%% Create additional reference systems (ChMarkers) 
    
    # Create a local reference system with origin in pixhawk and with NED (North East Down) convention
    marker_pixhawk =chrono.ChMarker()
    marker_pixhawk.SetName('Coordinate System Pixhawk')
    my_frame.AddMarker(marker_pixhawk)
    marker_pixhawk.Impose_Abs_Coord(pixhawk_csys)
    
    # Create a local reference system with origin in pixhawk and with Global Frame convention (Y up)
    
    pixhawk_csys_2 = chrono.ChCoordsysD(position_local_pixhawk,chrono.ChQuaternionD(1,0,0,0)) # Coordinate System Pixhawk
    
    marker_pixhawk_2 =chrono.ChMarker()
    marker_pixhawk_2.SetName('Coordinate System Pixhawk Global Frame convention')
    my_frame.AddMarker(marker_pixhawk_2)
    marker_pixhawk_2.Impose_Abs_Coord(pixhawk_csys_2)
    
    
    # my_frame.SetWvel_loc(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    # my_frame.SetWvel_par(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    
    # my_ball3.SetWvel_par(chrono.ChVectorD(1,0,0)) # ROLL YAW PITCH
    
    # # Rotation matrix that represents a rotation of minus pi/2 (-90 degrees) around the x-axis
    # RR = chrono.ChMatrix33D()
    # RRX_minusPI2 = [[1,0,0],
    #                 [0,0,-1],
    #                 [0,1,0]]
    # RR.SetMatr(RRX_minusPI2)
    
    # Rotation matrix that represents a rotation of plus pi/2 (90 degrees) around the x-axis
    RR = chrono.ChMatrix33D()
    RRX_plusPI2 = [[ 1, 0, 0],
                    [0, 0, 1],
                    [0,-1, 0]]
    RR.SetMatr(RRX_plusPI2)
    
    # QQ = chrono.ChQuaternionD(0.70710678118,-0.70710678118,0,0) # Rotation around x of -pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,-0.70710678118,0) # Rotation around y of -pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0,-0.70710678118) # Rotation around z of -pi/2
    
    # QQ = chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0) # Rotation around x of pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0.70710678118,0) # Rotation around y of pi/2
    # QQ = chrono.ChQuaternionD(0.70710678118,0,0,0.70710678118) # Rotation around z of pi/2
    
    # QQ = chrono.ChQuaternionD(0.96592582628,0.2588190451,0,0) # Rotation around x of 30 degrees
    
    # marker_pixhawk.SetRot(RR)
    # marker_pixhawk.SetRot(QQ)
    # my_frame.SetRot(RR)
    # my_frame.SetRot(QQ)
    
    # # Create a local reference system with origin in pixhawk and with NED (North East Down) convention
    # marker_ball3 =chrono.ChMarker()
    # marker_ball3.SetName('Coordinate System Ball 3')
    # my_ball3.AddMarker(marker_ball3)
    # marker_ball3.Impose_Abs_Coord(chrono.ChCoordsysD(chrono.ChVectorD(0,1,0),chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)))
    
    # Identify Local reference system of Box
    my_box_csys = my_box.GetFrame_REF_to_abs().GetCoord()
    
    # Identify Local reference system of Ball_1
    my_ball1_csys = my_ball1.GetFrame_REF_to_abs().GetCoord()
    
    # Identify Local reference system of Ball_2
    my_ball2_csys = my_ball2.GetFrame_REF_to_abs().GetCoord()
    
    # Identify Local reference system of drone frame
    my_frame_csys = my_frame.GetFrame_REF_to_abs().GetCoord()
    
    

    #%% Create a path that the drone has to follow
    
    # # # Create a ChLinePath geometry, and insert sub-paths # SLOT TRAJECTORY
    # # mpath = chrono.ChLinePath()
    # # mseg1 = chrono.ChLineSegment(chrono.ChVectorD(1, 1, 0), chrono.ChVectorD(2, 1, 0))
    # # mpath.AddSubLine(mseg1)
    # # marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(2, 1.5, 0)), 0.5, -chrono.CH_C_PI_2, chrono.CH_C_PI_2, True)
    # # mpath.AddSubLine(marc1)
    # # mseg2 = chrono.ChLineSegment(chrono.ChVectorD(2, 2, 0), chrono.ChVectorD(1, 2, 0))
    # # mpath.AddSubLine(mseg2)
    # # marc2 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(1, 1.5, 0)), 0.5, chrono.CH_C_PI_2, -chrono.CH_C_PI_2, True);
    # # mpath.AddSubLine(marc2)
    # # mpath.Set_closed(True)
    
    # # Create a ChLinePath geometry, and insert sub-paths # CIRCLE TRAJECTORY
    # mpath = chrono.ChLinePath()
    # marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(0, 1, 0), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), 1, chrono.CH_C_2PI, 0, False) # CIRCLE TRAJECTORY
    # mpath.AddSubLine(marc1)
    # mpath.Set_closed(True)
    
    # # Create a ChLineShape, a visualization asset for lines.
    # # The ChLinePath is a special type of ChLine and it can be visualized.
    # mpathasset = chrono.ChLineShape()
    # mpathasset.SetLineGeometry(mpath)
    # mpathasset.SetColor(chrono.ChColor(0,0,0))
    # mfloor.AddVisualShape(mpathasset)
    
    # # The trajectory constraint:
    # mtrajectory = chrono.ChLinkTrajectory()
    
    # # # Define which parts are connected (the trajectory is considered in the 2nd body).
    # # mtrajectory.Initialize(my_frame, # body1 that follows the trajectory
    # #           mfloor,                 # body2 that 'owns' the trajectory
    # #           position_local_pixhawk,  # point on body1 that will follow the trajectory
    # #           mpath)                # the trajectory (reuse the one already added to body2 as asset)
    
    # # Define which parts are connected (the trajectory is considered in the 2nd body).
    # mtrajectory.Initialize(my_frame, # body1 that follows the trajectory
    #           mfloor,                 # body2 that 'owns' the trajectory
    #           position_pixhawk_fromCOG,  # point on body1 that will follow the trajectory
    #           # !! WARNING: You have to use the coordinates that refer to the COG of the drone frame body, not the ones that refer to its body local coord.sys.!!!!
    #           mpath)                # the trajectory (reuse the one already added to body2 as asset)
              
    
    # # Optionally, set a function that gets the curvilinear
    # # abscyssa s of the line, as a function of time s(t). 
    # # By default it was simply  s=t.
    # mspacefx = chrono.ChFunction_Ramp(0, 0.38) # 0.38 for circular trajectory | 0.9 for slot trajectory
    # mtrajectory.Set_space_fx(mspacefx)
    
    # my_system.Add(mtrajectory)
    

    #%% Create a path that the ball3 has to follow
    
    # # # Create a ChLinePath geometry, and insert sub-paths # SLOT TRAJECTORY
    # # mpath = chrono.ChLinePath()
    # # mseg1 = chrono.ChLineSegment(chrono.ChVectorD(1, 1, 0), chrono.ChVectorD(2, 1, 0))
    # # mpath.AddSubLine(mseg1)
    # # marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(2, 1.5, 0)), 0.5, -chrono.CH_C_PI_2, chrono.CH_C_PI_2, True)
    # # mpath.AddSubLine(marc1)
    # # mseg2 = chrono.ChLineSegment(chrono.ChVectorD(2, 2, 0), chrono.ChVectorD(1, 2, 0))
    # # mpath.AddSubLine(mseg2)
    # # marc2 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(1, 1.5, 0)), 0.5, chrono.CH_C_PI_2, -chrono.CH_C_PI_2, True);
    # # mpath.AddSubLine(marc2)
    # # mpath.Set_closed(True)
    
    # # Create a ChLinePath geometry, and insert sub-paths # CIRCLE TRAJECTORY
    # mpath = chrono.ChLinePath()
    # marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(0, 1, 0), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), 1, chrono.CH_C_2PI, 0, False) # CIRCLE TRAJECTORY
    # mpath.AddSubLine(marc1)
    # mpath.Set_closed(True)
    
    # # Create a ChLineShape, a visualization asset for lines.
    # # The ChLinePath is a special type of ChLine and it can be visualized.
    # mpathasset = chrono.ChLineShape()
    # mpathasset.SetLineGeometry(mpath)
    # mpathasset.SetColor(chrono.ChColor(0,0,0))
    # mfloor.AddVisualShape(mpathasset)
    
    
    # # The trajectory constraint:
    # mtrajectory = chrono.ChLinkTrajectory()
    
    # # # Define which parts are connected (the trajectory is considered in the 2nd body).
    # # mtrajectory.Initialize(my_frame, # body1 that follows the trajectory
    # #           mfloor,                 # body2 that 'owns' the trajectory
    # #           position_local_pixhawk,  # point on body1 that will follow the trajectory
    # #           mpath)                # the trajectory (reuse the one already added to body2 as asset)
    
    # # Define which parts are connected (the trajectory is considered in the 2nd body).
    # mtrajectory.Initialize(my_ball3, # body1 that follows the trajectory
    #           mfloor,                 # body2 that 'owns' the trajectory
    #           chrono.ChVectorD(0, 0, 0),  # point on body1 that will follow the trajectory
    #           # !! WARNING: You have to use the coordinates that refer to the COG of the drone frame body, not the ones that refer to its body local coord.sys.!!!!
    #           mpath)                # the trajectory (reuse the one already added to body2 as asset)
              
    
    # # Optionally, set a function that gets the curvilinear
    # # abscyssa s of the line, as a function of time s(t). 
    # # By default it was simply  s=t.
    # mspacefx = chrono.ChFunction_Ramp(0, 0.38) # 0.38 for circular trajectory | 0.9 for slot trajectory
    # mtrajectory.Set_space_fx(mspacefx)
    
    # my_system.Add(mtrajectory)
    
    # my_ball3.SetWvel_loc(chrono.ChVectorD(0,5,0))
    # my_ball3.SetWvel_loc(chrono.ChVectorD(0,0,5))
    # my_ball3.SetBodyFixed(True)


    #%% Making the Propellers spin   
    
    revolute_frame1 = my_marker1.GetAbsFrame()
    link_motor1 = chrono.ChLinkMotorRotationSpeed()
    link_motor1.Initialize(my_prop1, my_frame, revolute_frame1)
    link_motor1.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor1.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    # link_motor1.SetMotorFunction(chrono.ChFunction_Const(250*chrono.CH_C_2PI))  # 250 Hz to rad/s
    my_system.Add(link_motor1)
    
    # omega_fun = chrono.ChFunction_Const(300)
    # link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_fun))
    
    revolute_frame2 = my_marker2.GetAbsFrame()
    link_motor2 = chrono.ChLinkMotorRotationSpeed()
    link_motor2.Initialize(my_prop2, my_frame, revolute_frame2)
    link_motor2.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor2.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor2)
    
    revolute_frame3 = my_marker3.GetAbsFrame()
    link_motor3 = chrono.ChLinkMotorRotationSpeed()
    link_motor3.Initialize(my_prop3, my_frame, revolute_frame3)
    link_motor3.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor3.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor3)
    
    revolute_frame4 = my_marker4.GetAbsFrame()
    link_motor4 = chrono.ChLinkMotorRotationSpeed()
    link_motor4.Initialize(my_prop4, my_frame, revolute_frame4)
    link_motor4.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor4.SetMotorFunction(chrono.ChFunction_Const(5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor4)
    
    revolute_frame5 = my_marker5.GetAbsFrame()
    link_motor5 = chrono.ChLinkMotorRotationSpeed()
    link_motor5.Initialize(my_prop5, my_frame, revolute_frame5)
    link_motor5.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor5.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor5)
    
    revolute_frame6 = my_marker6.GetAbsFrame()
    link_motor6 = chrono.ChLinkMotorRotationSpeed()
    link_motor6.Initialize(my_prop6, my_frame, revolute_frame6)
    link_motor6.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor6.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor6)
    
    revolute_frame7 = my_marker7.GetAbsFrame()
    link_motor7 = chrono.ChLinkMotorRotationSpeed()
    link_motor7.Initialize(my_prop7, my_frame, revolute_frame7)
    link_motor7.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor7.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor7)
    
    revolute_frame8 = my_marker8.GetAbsFrame()
    link_motor8 = chrono.ChLinkMotorRotationSpeed()
    link_motor8.Initialize(my_prop8, my_frame, revolute_frame8)
    link_motor8.SetSpindleConstraint(chrono.ChLinkMotorRotationSpeed.SpindleConstraint_CYLINDRICAL)
    # link_motor8.SetMotorFunction(chrono.ChFunction_Const(-5.0*chrono.CH_C_2PI))  # 5.0 Hz to rad/s
    my_system.Add(link_motor8)
    
    
    #%% Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
    
    # Get the mass of each body
    my_frame_mass = my_frame.GetMass()
    my_box_mass = my_box.GetMass()
    my_prop_mass = my_prop1.GetMass() # same for each propeller
    my_ball1_mass = my_ball1.GetMass()
    my_ball2_mass = my_ball2.GetMass()
    
    mass_total = my_frame_mass + my_box_mass + 8*(my_prop_mass)
    mass_total_wballs = my_frame_mass + my_box_mass + 8*(my_prop_mass) + my_ball1_mass + my_ball2_mass
    
    COG_total = chrono.ChVectorD()
    COG = chrono.ChVectorD()
    
    # !! The rest of the computation must be executed inside the final while loop !!

    #%% Forces and Torques
    
    my_frame.Accumulate_force(chrono.ChVectorD(0,0,0),chrono.VNULL,True)
    
    # Mixer Matrix for the realization of the thrust generated by each motor (T1, T2, T3, T4) given the control inputs (u1, u2, u3, u4)
    l_x = 0.0881269 # distance between centerline of the drone and the motors along x direction in Local NED convention
    l_y = 0.1083450 # distance between centerline of the drone and the motors along y direction in Local NED convention
    c_t = 0.01 # WRONG/RANDOM VALUE drag coefficient of propellers 0.01
    
    # U_mat = np.array([[ 1,    1,    1,    1  ],  # For QUADcopter config, not X8
    #                   [ l_y,  l_y, -l_y, -l_y],
    #                   [-l_x,  l_x,  l_x, -l_x],
    #                   [-c_t,  c_t, -c_t,  c_t]])
    
    # Mixer matrix for X8 configuration copter
    # [   1,   1,    1,    1,    1,    1,    1,    1]
    # [ l_y, l_y, -l_y, -l_y,  l_y,  l_y, -l_y, -l_y]
    # [-l_x, l_x,  l_x, -l_x, -l_x,  l_x,  l_x, -l_x]
    # [-c_t, c_t, -c_t,  c_t,  c_t, -c_t,  c_t, -c_t]
    
    # Moore-Penrose pseudo-inverse of mixer matrix
    # [1/8,  1/(8*l_y), -1/(8*l_x), -1/(8*c_t)],
    # [1/8,  1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
    # [1/8, -1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
    # [1/8, -1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
    # [1/8,  1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
    # [1/8,  1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
    # [1/8, -1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
    # [1/8, -1/(8*l_y), -1/(8*l_x), -1/(8*c_t)]
     
    # U_mat_inv = LA.inv(U_mat)
    
    U_mat_inv = np.array([[1/8,  1/(8*l_y), -1/(8*l_x), -1/(8*c_t)],
                          [1/8,  1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
                          [1/8, -1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
                          [1/8, -1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
                          [1/8,  1/(8*l_y), -1/(8*l_x),  1/(8*c_t)],
                          [1/8,  1/(8*l_y),  1/(8*l_x), -1/(8*c_t)],
                          [1/8, -1/(8*l_y),  1/(8*l_x),  1/(8*c_t)],
                          [1/8, -1/(8*l_y), -1/(8*l_x), -1/(8*c_t)]])
    
    #%% Trajectory parameters
    
    # ----------------------------------------------------------------
    #!!!                     CHOOSE THE TRAJECTORY
    # ----------------------------------------------------------------
    
    # trajectory_type = 'circular_trajectory'
    
    # trajectory_type = 'hover_trajectory'
    
    # trajectory_type = 'square_trajectory'
    
    # trajectory_type = 'roundedRectangle_trajectory'
    
    trajectory_type = 'piecewisePolynomial_trajectory'
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------
    
    
    if trajectory_type == 'circular_trajectory':
        # Circular trajectory at constant altitude
        radius_trajectory = 3 # 5
        angular_velocity_trajectory = 0.2 # 0.2
        altitude_trajectory = -1 # -1
        
        #################################################################################################################################################################
        # Create a ChLinePath geometry, and insert sub-paths # CIRCLE TRAJECTORY
        mpath = chrono.ChLinePath()
        marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(-radius_trajectory, abs(altitude_trajectory) + 0.3, 0), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), radius_trajectory, chrono.CH_C_2PI, 0, False) # CIRCLE TRAJECTORY
        # marc1 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(-2.5, 1.3, 0), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), 5, chrono.CH_C_2PI, 0, False) # CIRCLE TRAJECTORY
        mpath.AddSubLine(marc1)
        mpath.Set_closed(True)
    
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)
        ####################################################################################################################################################################
        
    elif trajectory_type == 'hover_trajectory':
        # Hover trajectory at constant altitude
        altitude_trajectory = -1 # -1
    
    elif trajectory_type == 'square_trajectory':
        # Square trajectory at constant altitude
        square_side_size = 5 # 5
        linear_velocity_trajectory = 3.5 # 1
        altitude_trajectory = -1
        ##################################################################################################################################################################
        # Create a ChLinePath geometry, and insert sub-paths # SQUARE TRAJECTORY
        mpath = chrono.ChLinePath()
    
        seg1 = chrono.ChLineSegment(chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,0),chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,0))
        seg2 = chrono.ChLineSegment(chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,0),chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,square_side_size))
        seg3 = chrono.ChLineSegment(chrono.ChVectorD(square_side_size,abs(altitude_trajectory) + 0.3,square_side_size),chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,square_side_size))
        seg4 = chrono.ChLineSegment(chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,square_side_size),chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,0))
    
        mpath.AddSubLine(seg1)
        mpath.AddSubLine(seg2)
        mpath.AddSubLine(seg3)
        mpath.AddSubLine(seg4)
        mpath.Set_closed(True)
    
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)
        ####################################################################################################################################################################
    
    elif trajectory_type == 'roundedRectangle_trajectory':
        # Rounded rectangle trajectory at a constant altitude
        # 22.5 seconds "Stadium": 5, 0, 2, 1, -1
        length_horizontal = 4
        length_vertical = 0
        rounding_radius = 1
        linear_velocity_trajectory = 1.5 # 1.2
        altitude_trajectory = -1.1
        
        # length_horizontal = 4
        # length_vertical = 0
        # rounding_radius = 0.3
        # linear_velocity_trajectory = 1.2 
        # altitude_trajectory = -1.1
        
        # length_horizontal = 5
        # length_vertical = 0
        # rounding_radius = 2
        # linear_velocity_trajectory = 1 
        # altitude_trajectory = -1
        ##################################################################################################################################################################
        # Create a ChLinePath geometry, and insert sub-paths # ROUNDED RECTANGLE TRAJECTORY
        mpath = chrono.ChLinePath()
    
        seg1 = chrono.ChLineSegment(chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,0),chrono.ChVectorD(length_horizontal,abs(altitude_trajectory) + 0.3,0))
        arc2 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(length_horizontal, abs(altitude_trajectory) + 0.3, rounding_radius), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, -PI/2, 0, True)
        seg3 = chrono.ChLineSegment(chrono.ChVectorD(length_horizontal + rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius),chrono.ChVectorD(length_horizontal + rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius + length_vertical))
        arc4 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(length_horizontal, abs(altitude_trajectory) + 0.3, rounding_radius + length_vertical), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, 0, PI/2, True)
        seg5 = chrono.ChLineSegment(chrono.ChVectorD(length_horizontal,abs(altitude_trajectory) + 0.3,2*rounding_radius + length_vertical),chrono.ChVectorD(0,abs(altitude_trajectory) + 0.3,2*rounding_radius + length_vertical))
        arc6 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(0, abs(altitude_trajectory) + 0.3, rounding_radius + length_vertical), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, PI/2, PI, True)
        seg7 = chrono.ChLineSegment(chrono.ChVectorD(-rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius + length_vertical),chrono.ChVectorD(-rounding_radius,abs(altitude_trajectory) + 0.3,rounding_radius))
        arc8 = chrono.ChLineArc(chrono.ChCoordsysD(chrono.ChVectorD(0, abs(altitude_trajectory) + 0.3, rounding_radius), chrono.ChQuaternionD(0.70710678118,0.70710678118,0,0)), rounding_radius, -PI, -PI/2, True)
        
        mpath.AddSubLine(seg1)
        mpath.AddSubLine(arc2)
        mpath.AddSubLine(seg3)
        mpath.AddSubLine(arc4)
        mpath.AddSubLine(seg5)
        mpath.AddSubLine(arc6)
        mpath.AddSubLine(seg7)
        mpath.AddSubLine(arc8)
        mpath.Set_closed(True)
    
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)
        ####################################################################################################################################################################
        
    elif trajectory_type == 'piecewisePolynomial_trajectory':
        pp_coefficients = np.loadtxt(open(
                                  "trajectory_PolynomialCoefficientMatrix.csv",
                                  "rb"), delimiter=",", skiprows=0)
        waypointTimes = np.loadtxt(open("trajectory_WaypointTimes.csv", "rb"),
                                   delimiter=",", skiprows=0)
        
        trajectory_instance = piecewisePolynomial_trajectory()
        trajectory_instance.set_parameters(pp_coefficients, waypointTimes)
        
        # Create a ChLinePath geometry, and insert sub-paths
        mpath = chrono.ChLinePath()
        [pos_x, pos_y, pos_z] = trajectory_instance.ComputePositionVector(0.01)
        
        for i in range(pos_x.size - 1):
          mpath.AddSubLine(chrono.ChLineSegment(
            chrono.ChVectorD(pos_x[i],
                             -pos_z[i] + mfloor_Yposition,
                             pos_y[i]),
            chrono.ChVectorD(pos_x[i+1],
                             -pos_z[i+1] + mfloor_Yposition,
                             pos_y[i+1])))
        
        # Create a ChLineShape, a visualization asset for lines.
        # The ChLinePath is a special type of ChLine and it can be visualized.
        mpathasset = chrono.ChLineShape()
        mpathasset.SetLineGeometry(mpath)
        mpathasset.SetColor(chrono.ChColor(0,0,0))
        mfloor.AddVisualShape(mpathasset)

    #%% Controller Inizialization
    
    T = np.array([0,0,0,0,0,0,0,0]) # Thrust inizialization
    U = np.array([0,0,0,0])
    torque_total = 0
    roll_ref = 0
    pitch_ref = 0
    mu_x = 0
    mu_y = 0
    mu_z = 0
    mu_PD_baseline_tran = np.zeros((3,1))
    mu_baseline_tran = np.zeros((3,1))
    mu_adaptive_tran = np.zeros((3,1))
    Moment_baseline_PI = np.zeros((3,1))
    Moment_baseline = np.zeros((3,1))
    Moment_adaptive = np.zeros((3,1))
    
    omega_ref_dot = np.zeros((3,1))
    omega_ref = np.zeros((3,1))
    omega_cmd = np.zeros((3,1))
    omega_cmd_dot = np.zeros((3,1))
    Jacobian_matrix = np.matrix(np.zeros((3,3)))
    Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
    angular_error = np.zeros((3,1))
    angular_error_dot = np.zeros((3,1))
    integral_angular_error = np.zeros((3,1))
    
    e_omega_ref_cmd = np.zeros((3,1))
    integral_e_omega_ref_cmd = np.zeros((3,1))
    
    
    # Maximum thrust produced by a single motor = 1355 grams = 1.355 kg = 1.355 kg * 9.81 m/s^2 = 13.28 N
    # Maximum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 13.28 * 2 = 26.56 N
    # Maximum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 26.56 N * 0.8 = 21.25 N
    # For reference see: https://www.getfpv.com/t-motor-pacer-v3-p2306-powerful-freestyle-motor-1750kv-1950kv-2550kv.html
    # T_MAX = 21.25 # [N] Maximum thrust that can be produced by a motors'couple
    T_MAX = 21.25/2 # [N] Maximum thrust that can be produced by a SINGLE motor = 10.625 N
    # T_MAX = 100000 # [N] Maximum thrust that can be produced by a SINGLE motor
    
    # Minimum thrust produced by a single motor = 80 grams = 0.08 kg = 0.08 kg * 9.81 m/s^2 = 0.7848 N
    # Minimum thrust produced by a motors'couple without loss of efficiency due to propeller interaction = 0.7848 * 2 = 1.5696 N
    # Minimum thrust produced by a motors'couple considering loss of efficiency due to propeller interaction = 1.5696 N * 0.8 = 1.255 N
    # T_MIN = 1.255 # [N] Minimum thrust that can be produced by a motors'couple
    T_MIN = 1.255/2 # [N] Minimum thrust that can be produced by a SINGLE motor = 0.6275 N
    # T_MIN = 0 # [N] Minimum thrust that can be produced by a SINGLE motor
    
    motor_efficiency_matrix = np.matrix(np.diag([1, 1, 1, 1, 1, 1, 1, 1]))
    
    # =============================================================================
    
    K_omega = 0.0000014166615 # Coefficent relating the propellers'thrust to the square of the angular velocity. T = K * omega^2
    K_torque = 5e-08 # [5e-08 - 5e-10] TO BE ESTIMATED!!! Coefficent relating the propellers'torque to the square of the angular velocity. Torque = K_torque * omega^2
    
    #########################
    # Roll filters gains (from matlab)
    A_phi_ref = np.matrix([[-15, -225],[1, 0]])
    B_phi_ref = np.array([[1],[0]])
    C_phi_ref = np.matrix([225, 0])
    D_phi_ref = 0
    # Pitch filters gains (from matlab)
    A_theta_ref = np.matrix([[-15, -225],[1, 0]])
    B_theta_ref = np.array([[1],[0]])
    C_theta_ref = np.matrix([225, 0])
    D_theta_ref = 0
    
    # Roll KF gain
    Q_phi = np.diag([1e-3, 1e-3])
    R_phi = 500;
    P_phi = linalg.solve_continuous_are(A_phi_ref.T, C_phi_ref.T, Q_phi, R_phi)
    K_phi = np.dot(np.dot(P_phi, C_phi_ref.T), 1 / R_phi)
    
    # Pitch KF gain
    Q_theta = np.diag([1e-3, 1e-3])
    R_theta = 500;
    P_theta = linalg.solve_continuous_are(A_theta_ref.T, C_theta_ref.T, Q_theta, R_theta)
    K_theta = np.dot(np.dot(P_theta, C_theta_ref.T), 1 / R_theta)
    #########################
    

    #%% Controller gains and TYPE
    
    ##########################!!!
    mass_total_estimated = 2.025 # [kg] 2.025
    # mass_total_estimated = 3.1 # [kg]
    I_matrix_estimated = np.matrix(Inertia_mat_pixhawk)
    air_density_estimated = air_density
    surface_area_estimated = surface_area
    drag_coefficient_estimated = drag_coefficient
    drag_coefficient_matrix_estimated = np.matrix(np.diag([drag_coefficient_estimated,drag_coefficient_estimated,0]))
    
    controller_start_time = 0.1 # Time after the start of simulation at which the controller is switched ON
    
    #########################
    
    # ----------------------------------------------------------------
    #                     CHOOSE THE CONTROLLER
    # ----------------------------------------------------------------
    
    # controller_type = 'PID' # Check mass_total_estimated
    
    # controller_type = 'MRACwithBASELINE'
    
    # controller_type = 'TwoLayerMRACwithBASELINE'
    
    # controller_type = 'RobustMRACwithBASELINE'
    
    #controller_type = 'RobustTwoLayerMRACwithBASELINE'
    
    # controller_type = 'HybridMRACwithBASELINE'
    
    # controller_type = 'HybridTwoLayerMRACwithBASELINE'
    
    # controller_type = 'HybridRobustMRACwithBASELINE'
    
    # controller_type = 'HybridRobustTwoLayerMRACwithBASELINE'
    
    # controller_type = 'FunnelMRACwithBASELINE'
    
    # controller_type = 'FunnelTwoLayerMRACwithBASELINE'
    
    # controller_type = 'MRACwithBASELINE_SafetyMechanism'
    
    # ----------------------------------------------------------------
    #                     %%%%%%%%%%%%%%%%%%%%%%
    # ----------------------------------------------------------------
    
    if controller_type == 'PID':
        # Gains PID
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_rot,KD_rot,KI_rot,sphereEpsilon,maximumThrust,
        EllipticConeEpsilon,maximumRollAngle,maximumPitchAngle,planeEpsilon,alphaPlane] = Gains.PID()
        
    elif controller_type == 'MRACwithBASELINE':
        # Gains MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,Q_tran,P_tran,K_x_tran_bar,K_r_tran_bar,A_rot,
        B_rot,A_ref_rot,B_ref_rot,Q_rot,P_rot,Gamma_x_rot,Gamma_r_rot,
        Gamma_Theta_rot] = Gains.MRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
        
    elif controller_type == 'TwoLayerMRACwithBASELINE':
        # Gains Two-Layer MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,A_rot,B_rot,A_ref_rot,
        B_ref_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,A_transient_tran,Q_tran_2Layer,P_tran_2Layer,Gamma_g_tran,
        A_transient_rot,Q_rot_2Layer,P_rot_2Layer,Gamma_g_rot,K_x_tran_bar,K_r_tran_bar,
        K_g_tran_bar] = Gains.TwoLayerMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
    
    elif controller_type == 'RobustMRACwithBASELINE':
        # Gains Robust MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,Q_tran,P_tran,K_x_tran_bar,K_r_tran_bar,A_rot,
        B_rot,A_ref_rot,B_ref_rot,Q_rot,P_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,sigma_x_tran,sigma_r_tran,sigma_theta_tran,sigma_x_rot,sigma_r_rot,
        sigma_theta_rot] = Gains.RobustMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
    
    elif controller_type == 'RobustTwoLayerMRACwithBASELINE':
        # Gains Robust Two-Layer MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,A_rot,B_rot,A_ref_rot,
        B_ref_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,A_transient_tran,Q_tran_2Layer,P_tran_2Layer,Gamma_g_tran,
        A_transient_rot,Q_rot_2Layer,P_rot_2Layer,Gamma_g_rot,K_x_tran_bar,K_r_tran_bar,K_g_tran_bar,sigma_x_tran,sigma_r_tran,
        sigma_theta_tran,sigma_g_tran,sigma_x_rot,sigma_r_rot,sigma_theta_rot,
        sigma_g_rot] = Gains.RobustTwoLayerMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
    
    elif controller_type == 'HybridMRACwithBASELINE':
        # Gains Hybrid MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
         KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
         A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,Q_tran,P_tran,K_x_tran_bar,K_r_tran_bar,A_rot,
         B_rot,A_ref_rot,B_ref_rot,Q_rot,P_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,flag_first_loop_controller,
         time_reset_trajectory_tran,time_reset_trajectory_rot,e_tran,e_rot,summation_hybrid_P_tran,summation_hybrid_P_rot,s_hybrid_tran,s_hybrid_rot,
         tollerance_time_reset_series] = Gains.HybridMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)    
    
    elif controller_type == 'HybridTwoLayerMRACwithBASELINE':
        # Gains Hybrid Two-Layer MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,A_rot,B_rot,A_ref_rot,
        B_ref_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,A_transient_tran,Q_tran_2Layer,P_tran_2Layer,Gamma_g_tran,
        A_transient_rot,Q_rot_2Layer,P_rot_2Layer,Gamma_g_rot,K_x_tran_bar,K_r_tran_bar,K_g_tran_bar,flag_first_loop_controller,
        time_reset_trajectory_tran,time_reset_trajectory_rot,epsilon_tran,epsilon_rot,summation_hybrid_P_tran,summation_hybrid_P_rot,s_hybrid_tran,s_hybrid_rot,
        tollerance_time_reset_series,e_transient_tran,e_transient_rot,summation_hybrid_transient_P_tran,summation_hybrid_transient_P_rot,s_hybrid_transient_tran,
        s_hybrid_transient_rot] = Gains.HybridTwoLayerMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
        
    elif controller_type == 'HybridRobustMRACwithBASELINE':
        # Gains HybridRobust MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,Q_tran,P_tran,K_x_tran_bar,K_r_tran_bar,A_rot,
        B_rot,A_ref_rot,B_ref_rot,Q_rot,P_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,sigma_x_tran,sigma_r_tran,sigma_theta_tran,sigma_x_rot,sigma_r_rot,
        sigma_theta_rot,flag_first_loop_controller,time_reset_trajectory_tran,time_reset_trajectory_rot,e_tran,e_rot,summation_hybrid_P_tran,
        summation_hybrid_P_rot,s_hybrid_tran,s_hybrid_rot,
        tollerance_time_reset_series] = Gains.HybridRobustMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
    
    elif controller_type == 'HybridRobustTwoLayerMRACwithBASELINE':
        # Gains Robust Two-Layer MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,A_rot,B_rot,A_ref_rot,
        B_ref_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,A_transient_tran,Q_tran_2Layer,P_tran_2Layer,Gamma_g_tran,
        A_transient_rot,Q_rot_2Layer,P_rot_2Layer,Gamma_g_rot,K_x_tran_bar,K_r_tran_bar,K_g_tran_bar,sigma_x_tran,sigma_r_tran,
        sigma_theta_tran,sigma_g_tran,sigma_x_rot,sigma_r_rot,sigma_theta_rot,
        sigma_g_rot,flag_first_loop_controller,time_reset_trajectory_tran,time_reset_trajectory_rot,epsilon_tran,epsilon_rot,
        summation_hybrid_P_tran,summation_hybrid_P_rot,s_hybrid_tran,s_hybrid_rot,tollerance_time_reset_series,e_transient_tran,
        e_transient_rot,summation_hybrid_transient_P_tran,summation_hybrid_transient_P_rot,s_hybrid_transient_tran,
        s_hybrid_transient_rot] = Gains.HybridRobustTwoLayerMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
    
    elif controller_type == 'FunnelMRACwithBASELINE':
        # Gains Funnel MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,Q_tran,P_tran,K_x_tran_bar,K_r_tran_bar,A_rot,
        B_rot,A_ref_rot,B_ref_rot,Q_rot,P_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,eta_max_funnel_tran,M_funnel_tran,u_max,u_min,
        Delta_u_min,nu_funnel_tran,eta_max_funnel_rot,M_funnel_rot,Moment_max,Moment_min,Delta_Moment_min,
        nu_funnel_rot] = Gains.FunnelMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
    
    elif controller_type == 'FunnelTwoLayerMRACwithBASELINE':
        # Gains Two-Layer MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,A_rot,B_rot,A_ref_rot,
        B_ref_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,A_transient_tran,Q_tran_2Layer,P_tran_2Layer,Gamma_g_tran,
        A_transient_rot,Q_rot_2Layer,P_rot_2Layer,Gamma_g_rot,K_x_tran_bar,K_r_tran_bar,K_g_tran_bar,eta_max_funnel_tran,
        M_funnel_tran,u_max,u_min,Delta_u_min,nu_funnel_tran,eta_max_funnel_rot,M_funnel_rot,Moment_max,Moment_min,
        Delta_Moment_min,nu_funnel_rot] = Gains.FunnelTwoLayerMRACwithBASELINE(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
        
    elif controller_type == 'MRACwithBASELINE_SafetyMechanism':
        # Gains MRAC with Baseline
        [number_of_states,size_DATA,KP_tran,KD_tran,KI_tran,KP_tran_PD_baseline,KD_tran_PD_baseline,KP_rot,KI_rot,KP_rot_PI_baseline,
        KD_rot_PI_baseline,KI_rot_PI_baseline,K_P_omega_ref,K_I_omega_ref,A_tran,B_tran,A_tran_bar,Lambda_bar,Theta_tran_adaptive_bar,
        A_ref_tran,B_ref_tran,Gamma_x_tran,Gamma_r_tran,Gamma_Theta_tran,Gamma_Theta_tran,Q_tran,P_tran,K_x_tran_bar,K_r_tran_bar,A_rot,
        B_rot,A_ref_rot,B_ref_rot,Q_rot,P_rot,Gamma_x_rot,Gamma_r_rot,Gamma_Theta_rot,sphereEpsilon,maximumThrust,
        EllipticConeEpsilon,maximumRollAngle,maximumPitchAngle,planeEpsilon,
        alphaPlane] = Gains.MRACwithBASELINE_SafetyMechanism(mass_total_estimated, air_density_estimated, surface_area_estimated, drag_coefficient_matrix_estimated)
    
    
    #%% Control Algorithms ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    # Initial conditions
    y0 = np.zeros((number_of_states,1))
    
    Y = np.zeros((number_of_states,1))
    Y_list = Y
    Y[:, 0] = np.ravel(y0)
    yin = y0
    
    dy = np.zeros((number_of_states,1))
    y = np.zeros((number_of_states,1))
    
    
        
    class controller:
        def PID(t, y):
            """
            This function defines the system of equations of the PID CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4
            
            state_phi_ref_diff = y[0:2]
            state_theta_ref_diff = y[2:4]
            state_phi_ref_diff_fil = y[4:6]
            state_theta_ref_diff_fil = y[6:8]
            integral_position_tracking = y[8:11]
            integral_angular_error = y[11:14]
            
            mu_tran_raw = mass_total_estimated*(-KP_tran * translational_position_error - KD_tran * (translational_velocity_in_I - translational_velocity_in_I_user) - KI_tran * integral_position_tracking + translational_acceleration_in_I_user).reshape(3,1)
            mu_x_raw = mu_tran_raw[0].item()
            mu_y_raw = mu_tran_raw[1].item()
            mu_z_raw = mu_tran_raw[2].item()
            #----------------
            # Safety Mechanism
            
            # Mu - sphere intersection
            tSphereVector = np.zeros((2,1))
            if LA.norm(mu_tran_raw) >= sphereEpsilon:
                tSphereVector[0] = (mu_z_raw*mass_total_estimated*G_acc + math.sqrt((mu_z_raw*mass_total_estimated*G_acc)**2 +
                                    LA.norm(mu_tran_raw)**2 * (maximumThrust**2 - (mass_total_estimated*G_acc)**2)))/LA.norm(mu_tran_raw)**2
                tSphereVector[1] = (mu_z_raw*mass_total_estimated*G_acc - math.sqrt((mu_z_raw*mass_total_estimated*G_acc)**2 +
                                    LA.norm(mu_tran_raw)**2 * (maximumThrust**2 - (mass_total_estimated*G_acc)**2)))/LA.norm(mu_tran_raw)**2
            else:
                tSphereVector[0] = math.nan
                tSphereVector[1] = math.nan
            
            # Mu - elliptic cone intersection
            tEllipticConeVector = np.zeros((2,1))
            if abs(mu_z_raw + math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 +
                                        (mu_y_raw/math.tan(maximumRollAngle))**2)) >= EllipticConeEpsilon:
                tEllipticConeVector[0] = (mass_total_estimated*G_acc)/(mu_z_raw + 
                                          math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 + (mu_y_raw/math.tan(maximumRollAngle))**2))
            else:
                tEllipticConeVector[0] = math.nan
                
            if abs(-mu_z_raw + math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 +
                                        (mu_y_raw/math.tan(maximumRollAngle))**2)) >= EllipticConeEpsilon:
                tEllipticConeVector[1] = -(mass_total_estimated*G_acc)/(-mu_z_raw + 
                                          math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 + (mu_y_raw/math.tan(maximumRollAngle))**2))
            else:
                tEllipticConeVector[1] = math.nan
                
            # Mu - plane intersection
            if abs(mu_z_raw) >= planeEpsilon:
                tPlane = alphaPlane*mass_total_estimated*G_acc/mu_z_raw
            else:
                tPlane = math.nan
                
            tVector = np.array([tSphereVector[0].item(),tSphereVector[1].item(),
                                tEllipticConeVector[0].item(),tEllipticConeVector[1].item(),tPlane])
            for i in range(0,tVector.size):
                if tVector[i] < 0:
                    tVector[i] = math.nan
                    
            tValue = min(tVector)
            
            if tValue > 1:
                tValue = 1
            tValue = 1 # If this is uncommented, safety mechanism is OFF   
            mu_tran = tValue * mu_tran_raw
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            #----------------
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
            
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Moment = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1) + I_matrix_estimated * (-KP_rot * angular_error - KD_rot * angular_error_dot - KI_rot * integral_angular_error + angular_position_ref_ddot).reshape(3,1)
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:11] = translational_position_error
            dy[11:14] = angular_error
            
    
        
            return np.array(dy)
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        
        def MRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, omega_ref_dot, omega_cmd, omega_cmd_dot, Jacobian_matrix
            global Jacobian_matrix_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)

            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * P_tran * B_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * P_tran * B_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * P_tran * B_tran
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])

            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * P_rot * B_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * P_rot * B_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * P_rot * B_rot
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        
        def TwoLayerMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the 2-Layer MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            e_transient_tran = y[104:110] # Transient error dynamics translational (Two-layer) 
            K_hat_g_tran = y[110:128] # \hat{K}_g translational (Two-layer) 
            e_transient_rot = y[128:131] # Transient error dynamics rotational (Two-layer) 
            K_hat_g_rot = y[131:140] # \hat{K}_g (rotational)(Two-layer)
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            K_hat_g_tran = np.matrix(K_hat_g_tran.reshape(6,3))
            K_hat_g_rot = np.matrix(K_hat_g_rot.reshape(3,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            e_transient_tran_dot = A_transient_tran * e_transient_tran
            epsilon_tran = e_tran - e_transient_tran
            e_transient_rot_dot = A_transient_rot * e_transient_rot
            epsilon_rot = e_rot - e_transient_rot
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented + K_g_tran_bar.T * e_tran
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented + K_hat_g_tran.T * e_tran
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * epsilon_tran.T * P_tran_2Layer * B_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * epsilon_tran.T * P_tran_2Layer * B_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * epsilon_tran.T * P_tran_2Layer * B_tran
            K_hat_g_tran_dot = -Gamma_g_tran * e_tran * epsilon_tran.T * P_tran_2Layer * B_tran
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * epsilon_rot.T * P_rot_2Layer * B_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * epsilon_rot.T * P_rot_2Layer * B_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * epsilon_rot.T * P_rot_2Layer * B_rot
            K_hat_g_rot_dot = -Gamma_g_rot * e_rot * epsilon_rot.T * P_rot_2Layer * B_rot
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented + K_hat_g_rot.T * e_rot
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104:110] = e_transient_tran_dot
            dy[110:128] = K_hat_g_tran_dot.reshape(18,1)
            dy[128:131] = e_transient_rot_dot
            dy[131:140] = K_hat_g_rot_dot.reshape(9,1)
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def RobustMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Robust (sigma-mod and e-mod) MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            # sigma-modification **Translational** --------------------------------------------------------------------------------------------------
            # K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * P_tran * B_tran - sigma_x_tran * K_hat_x_tran
            # K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * P_tran * B_tran - sigma_r_tran * K_hat_r_tran
            # Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * P_tran * B_tran - sigma_theta_tran * Theta_hat_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Translational** --------------------------------------------------------------------------------------------------
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * P_tran * B_tran - sigma_x_tran * LA.norm(e_tran.T * P_tran * B_tran) * K_hat_x_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * P_tran * B_tran - sigma_r_tran * LA.norm(e_tran.T * P_tran * B_tran) * K_hat_r_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * P_tran * B_tran - sigma_theta_tran * LA.norm(e_tran.T * P_tran * B_tran) * Theta_hat_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            # sigma-modification **Rotational** -----------------------------------------------------------------------------------------------------
            # K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * P_rot * B_rot - sigma_x_rot * K_hat_x_rot
            # K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * P_rot * B_rot - sigma_r_rot * K_hat_r_rot
            # Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * P_rot * B_rot - sigma_theta_rot * Theta_hat_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Rotational** -----------------------------------------------------------------------------------------------------
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * P_rot * B_rot - sigma_x_rot * LA.norm(e_rot.T * P_rot * B_rot) * K_hat_x_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * P_rot * B_rot - sigma_r_rot * LA.norm(e_rot.T * P_rot * B_rot) * K_hat_r_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * P_rot * B_rot - sigma_theta_rot * LA.norm(e_rot.T * P_rot * B_rot) * Theta_hat_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def RobustTwoLayerMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Robust (sigma-mod and e-mod) 2-Layer MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            e_transient_tran = y[104:110] # Transient error dynamics translational (Two-layer) 
            K_hat_g_tran = y[110:128] # \hat{K}_g translational (Two-layer) 
            e_transient_rot = y[128:131] # Transient error dynamics rotational (Two-layer) 
            K_hat_g_rot = y[131:140] # \hat{K}_g (rotational)(Two-layer)
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            K_hat_g_tran = np.matrix(K_hat_g_tran.reshape(6,3))
            K_hat_g_rot = np.matrix(K_hat_g_rot.reshape(3,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            e_transient_tran_dot = A_transient_tran * e_transient_tran
            epsilon_tran = e_tran - e_transient_tran
            e_transient_rot_dot = A_transient_rot * e_transient_rot
            epsilon_rot = e_rot - e_transient_rot
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented + K_g_tran_bar.T * e_tran
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented + K_hat_g_tran.T * e_tran
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            # sigma-modification **Translational** --------------------------------------------------------------------------------------------------
            # K_hat_x_tran_dot = -Gamma_x_tran * x_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_x_tran * K_hat_x_tran
            # K_hat_r_tran_dot = -Gamma_r_tran * r_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_r_tran * K_hat_r_tran
            # Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_theta_tran * Theta_hat_tran
            # K_hat_g_tran_dot = -Gamma_g_tran * e_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_g_tran * K_hat_g_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Translational** ------------------------------------------------------------------------------------------------------
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_x_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * K_hat_x_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_r_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * K_hat_r_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_theta_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * Theta_hat_tran
            K_hat_g_tran_dot = -Gamma_g_tran * e_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_g_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * K_hat_g_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
      
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            # sigma-modification **Rotational** -----------------------------------------------------------------------------------------------------
            # K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_x_rot * K_hat_x_rot
            # K_hat_r_rot_dot = -Gamma_r_rot * r_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_r_rot * K_hat_r_rot
            # Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_theta_rot * Theta_hat_rot
            # K_hat_g_rot_dot = -Gamma_g_rot * e_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_g_rot * K_hat_g_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Rotational** ---------------------------------------------------------------------------------------------------------
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_x_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * K_hat_x_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_r_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * K_hat_r_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_theta_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * Theta_hat_rot
            K_hat_g_rot_dot = -Gamma_g_rot * e_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_g_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * K_hat_g_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented + K_hat_g_rot.T * e_rot
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104:110] = e_transient_tran_dot
            dy[110:128] = K_hat_g_tran_dot.reshape(18,1)
            dy[128:131] = e_transient_rot_dot
            dy[131:140] = K_hat_g_rot_dot.reshape(9,1)
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def HybridMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Hybrid MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, e_tran, integral_eQe_tran, e_rot, integral_eQe_rot, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            integral_eQe_tran = y[104] # Integral of e_tran.T * Q_tran * e_tran
            integral_eQe_rot = y[105] # Integral of e_rot.T * Q_rot * e_rot
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * P_tran * B_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * P_tran * B_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * P_tran * B_tran
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * P_rot * B_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * P_rot * B_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * P_rot * B_rot
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104] = e_tran.T * Q_tran * e_tran
            dy[105] = e_rot.T * Q_rot * e_rot
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def HybridTwoLayerMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Hybrid 2-Layer MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, epsilon_tran, integral_epsQeps_tran, epsilon_rot, integral_epsQeps_rot
            global e_transient_tran, integral_etQet_tran, e_transient_rot, integral_etQet_rot, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            e_transient_tran = y[104:110] # Transient error dynamics translational (Two-layer) 
            K_hat_g_tran = y[110:128] # \hat{K}_g translational (Two-layer) 
            e_transient_rot = y[128:131] # Transient error dynamics rotational (Two-layer) 
            K_hat_g_rot = y[131:140] # \hat{K}_g (rotational)(Two-layer)
            integral_epsQeps_tran = y[140] # Integral of epsilon_tran.T * Q_tran_2Layer * epsilon_tran
            integral_epsQeps_rot = y[141] # Integral of epsilon_rot.T * Q_rot_2Layer * epsilon_rot
            integral_etQet_tran = y[142] # Integral of e_transient_tran.T * Q_tran_2Layer * e_transient_tran
            integral_etQet_rot = y[143] # Integral of e_transient_rot.T * Q_rot_2Layer * e_transient_rot
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            K_hat_g_tran = np.matrix(K_hat_g_tran.reshape(6,3))
            K_hat_g_rot = np.matrix(K_hat_g_rot.reshape(3,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            e_transient_tran_dot = A_transient_tran * e_transient_tran
            epsilon_tran = e_tran - e_transient_tran
            e_transient_rot_dot = A_transient_rot * e_transient_rot
            epsilon_rot = e_rot - e_transient_rot
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented + K_g_tran_bar.T * e_tran
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented + K_hat_g_tran.T * e_tran
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * epsilon_tran.T * P_tran_2Layer * B_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * epsilon_tran.T * P_tran_2Layer * B_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * epsilon_tran.T * P_tran_2Layer * B_tran
            K_hat_g_tran_dot = -Gamma_g_tran * e_tran * epsilon_tran.T * P_tran_2Layer * B_tran
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * epsilon_rot.T * P_rot_2Layer * B_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * epsilon_rot.T * P_rot_2Layer * B_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * epsilon_rot.T * P_rot_2Layer * B_rot
            K_hat_g_rot_dot = -Gamma_g_rot * e_rot * epsilon_rot.T * P_rot_2Layer * B_rot
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented + K_hat_g_rot.T * e_rot
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104:110] = e_transient_tran_dot
            dy[110:128] = K_hat_g_tran_dot.reshape(18,1)
            dy[128:131] = e_transient_rot_dot
            dy[131:140] = K_hat_g_rot_dot.reshape(9,1)
            dy[140] = epsilon_tran.T * Q_tran_2Layer * epsilon_tran
            dy[141] = epsilon_rot.T * Q_rot_2Layer * epsilon_rot
            dy[142] = e_transient_tran.T * Q_tran_2Layer * e_transient_tran
            dy[143] = e_transient_rot.T * Q_rot_2Layer * e_transient_rot
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def HybridRobustMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Hybrid Robust (sigma-mod and e-mod) MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, e_tran, integral_eQe_tran, e_rot, integral_eQe_rot, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            integral_eQe_tran = y[104] # Integral of e_tran.T * Q_tran * e_tran
            integral_eQe_rot = y[105] # Integral of e_rot.T * Q_rot * e_rot
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            # sigma-modification **Translational** --------------------------------------------------------------------------------------------------
            # K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * P_tran * B_tran - sigma_x_tran * K_hat_x_tran
            # K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * P_tran * B_tran - sigma_r_tran * K_hat_r_tran
            # Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * P_tran * B_tran - sigma_theta_tran * Theta_hat_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Translational** --------------------------------------------------------------------------------------------------
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * P_tran * B_tran - sigma_x_tran * LA.norm(e_tran.T * P_tran * B_tran) * K_hat_x_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * P_tran * B_tran - sigma_r_tran * LA.norm(e_tran.T * P_tran * B_tran) * K_hat_r_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * P_tran * B_tran - sigma_theta_tran * LA.norm(e_tran.T * P_tran * B_tran) * Theta_hat_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()            
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            # sigma-modification **Rotational** -----------------------------------------------------------------------------------------------------
            # K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * P_rot * B_rot - sigma_x_rot * K_hat_x_rot
            # K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * P_rot * B_rot - sigma_r_rot * K_hat_r_rot
            # Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * P_rot * B_rot - sigma_theta_rot * Theta_hat_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Rotational** -----------------------------------------------------------------------------------------------------
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * P_rot * B_rot - sigma_x_rot * LA.norm(e_rot.T * P_rot * B_rot) * K_hat_x_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * P_rot * B_rot - sigma_r_rot * LA.norm(e_rot.T * P_rot * B_rot) * K_hat_r_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * P_rot * B_rot - sigma_theta_rot * LA.norm(e_rot.T * P_rot * B_rot) * Theta_hat_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104] = e_tran.T * Q_tran * e_tran
            dy[105] = e_rot.T * Q_rot * e_rot
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
        def HybridRobustTwoLayerMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Robust (sigma-mod and e-mod) 2-Layer MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, epsilon_tran, integral_epsQeps_tran, epsilon_rot, integral_epsQeps_rot
            global e_transient_tran, integral_etQet_tran, e_transient_rot, integral_etQet_rot, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            e_transient_tran = y[104:110] # Transient error dynamics translational (Two-layer) 
            K_hat_g_tran = y[110:128] # \hat{K}_g translational (Two-layer) 
            e_transient_rot = y[128:131] # Transient error dynamics rotational (Two-layer) 
            K_hat_g_rot = y[131:140] # \hat{K}_g (rotational)(Two-layer)
            integral_epsQeps_tran = y[140] # Integral of epsilon_tran.T * Q_tran_2Layer * epsilon_tran
            integral_epsQeps_rot = y[141] # Integral of epsilon_rot.T * Q_rot_2Layer * epsilon_rot
            integral_etQet_tran = y[142] # Integral of e_transient_tran.T * Q_tran_2Layer * e_transient_tran
            integral_etQet_rot = y[143] # Integral of e_transient_rot.T * Q_rot_2Layer * e_transient_rot
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            K_hat_g_tran = np.matrix(K_hat_g_tran.reshape(6,3))
            K_hat_g_rot = np.matrix(K_hat_g_rot.reshape(3,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            e_transient_tran_dot = A_transient_tran * e_transient_tran
            epsilon_tran = e_tran - e_transient_tran
            e_transient_rot_dot = A_transient_rot * e_transient_rot
            epsilon_rot = e_rot - e_transient_rot
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented + K_g_tran_bar.T * e_tran
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented + K_hat_g_tran.T * e_tran
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            # sigma-modification **Translational** --------------------------------------------------------------------------------------------------
            # K_hat_x_tran_dot = -Gamma_x_tran * x_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_x_tran * K_hat_x_tran
            # K_hat_r_tran_dot = -Gamma_r_tran * r_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_r_tran * K_hat_r_tran
            # Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_theta_tran * Theta_hat_tran
            # K_hat_g_tran_dot = -Gamma_g_tran * e_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_g_tran * K_hat_g_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Translational** ------------------------------------------------------------------------------------------------------
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_x_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * K_hat_x_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_r_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * K_hat_r_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_theta_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * Theta_hat_tran
            K_hat_g_tran_dot = -Gamma_g_tran * e_tran * epsilon_tran.T * P_tran_2Layer * B_tran - sigma_g_tran * LA.norm(epsilon_tran.T * P_tran_2Layer * B_tran) * K_hat_g_tran
            # ---------------------------------------------------------------------------------------------------------------------------------------
      
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            # sigma-modification **Rotational** -----------------------------------------------------------------------------------------------------
            # K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_x_rot * K_hat_x_rot
            # K_hat_r_rot_dot = -Gamma_r_rot * r_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_r_rot * K_hat_r_rot
            # Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_theta_rot * Theta_hat_rot
            # K_hat_g_rot_dot = -Gamma_g_rot * e_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_g_rot * K_hat_g_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            # e-modification **Rotational** ---------------------------------------------------------------------------------------------------------
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_x_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * K_hat_x_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_r_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * K_hat_r_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_theta_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * Theta_hat_rot
            K_hat_g_rot_dot = -Gamma_g_rot * e_rot * epsilon_rot.T * P_rot_2Layer * B_rot - sigma_g_rot * LA.norm(epsilon_rot.T * P_rot_2Layer * B_rot) * K_hat_g_rot
            # ---------------------------------------------------------------------------------------------------------------------------------------
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented + K_hat_g_rot.T * e_rot
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104:110] = e_transient_tran_dot
            dy[110:128] = K_hat_g_tran_dot.reshape(18,1)
            dy[128:131] = e_transient_rot_dot
            dy[131:140] = K_hat_g_rot_dot.reshape(9,1)
            dy[140] = epsilon_tran.T * Q_tran_2Layer * epsilon_tran
            dy[141] = epsilon_rot.T * Q_rot_2Layer * epsilon_rot
            dy[142] = e_transient_tran.T * Q_tran_2Layer * e_transient_tran
            dy[143] = e_transient_rot.T * Q_rot_2Layer * e_transient_rot
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def FunnelMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Funnel MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            eta_funnel_tran = y[104] # eta used to compute the translational dynamics funnel diameter
            eta_funnel_rot = y[105] # eta used to compute the rotational dynamics funnel diameter
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)

            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            H_function_funnel_tran = eta_max_funnel_tran - eta_funnel_tran**2 - e_tran.T * M_funnel_tran * e_tran
            Ve_funnel_tran = (e_tran.T * P_tran * e_tran)/H_function_funnel_tran
            
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * (P_tran + M_funnel_tran * Ve_funnel_tran.item()) * B_tran/H_function_funnel_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * (P_tran + M_funnel_tran * Ve_funnel_tran.item()) * B_tran/H_function_funnel_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * (P_tran + M_funnel_tran * Ve_funnel_tran.item()) * B_tran/H_function_funnel_tran        
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            xi_funnel_tran_temp = (u_max - u1)/max(u1 - u_min, Delta_u_min)
            xi_funnel_tran = (e_tran.T * Q_tran * e_tran >= 2 * Ve_funnel_tran * eta_funnel_tran**2 * xi_funnel_tran_temp + nu_funnel_tran) * (H_function_funnel_tran > 0) * xi_funnel_tran_temp
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            H_function_funnel_rot = eta_max_funnel_rot - eta_funnel_rot**2 - e_rot.T * M_funnel_rot * e_rot
            Ve_funnel_rot = (e_rot.T * P_rot * e_rot)/H_function_funnel_rot
            
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * (P_rot + M_funnel_rot * Ve_funnel_rot.item()) * B_rot/H_function_funnel_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * (P_rot + M_funnel_rot * Ve_funnel_rot.item()) * B_rot/H_function_funnel_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * (P_rot + M_funnel_rot * Ve_funnel_rot.item()) * B_rot/H_function_funnel_rot
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            xi_funnel_rot_temp = (Moment_max - LA.norm(Moment))/max(LA.norm(Moment) - Moment_min, Delta_Moment_min)
            xi_funnel_rot = (e_rot.T * Q_rot * e_rot >= 2 * Ve_funnel_rot * eta_funnel_rot**2 * xi_funnel_rot_temp + nu_funnel_rot) * (H_function_funnel_rot > 0) * xi_funnel_rot_temp
            
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104] = eta_funnel_tran * xi_funnel_tran
            dy[105] = eta_funnel_rot * xi_funnel_rot
         
            return np.array(dy)
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def FunnelTwoLayerMRACwithBASELINE(t, y):
            """
            This function defines the system of equations of the Funnel 2-Layer MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, omega_ref_dot
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            e_transient_tran = y[104:110] # Transient error dynamics translational (Two-layer) 
            K_hat_g_tran = y[110:128] # \hat{K}_g translational (Two-layer) 
            e_transient_rot = y[128:131] # Transient error dynamics rotational (Two-layer) 
            K_hat_g_rot = y[131:140] # \hat{K}_g (rotational)(Two-layer)
            eta_funnel_tran = y[140] # eta used to compute the translational dynamics funnel diameter
            eta_funnel_rot = y[141] # eta used to compute the rotational dynamics funnel diameter
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            K_hat_g_tran = np.matrix(K_hat_g_tran.reshape(6,3))
            K_hat_g_rot = np.matrix(K_hat_g_rot.reshape(3,3))
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            e_transient_tran_dot = A_transient_tran * e_transient_tran
            epsilon_tran = e_tran - e_transient_tran
            e_transient_rot_dot = A_transient_rot * e_transient_rot
            epsilon_rot = e_rot - e_transient_rot
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
            
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented + K_g_tran_bar.T * e_tran
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented + K_hat_g_tran.T * e_tran
            mu_tran = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            H_function_funnel_tran = eta_max_funnel_tran - eta_funnel_tran**2 - e_tran.T * M_funnel_tran * e_tran
            Ve_funnel_tran = (epsilon_tran.T * P_tran_2Layer * epsilon_tran)/H_function_funnel_tran
            
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * epsilon_tran.T * (P_tran_2Layer + M_funnel_tran * Ve_funnel_tran.item()) * B_tran/H_function_funnel_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * epsilon_tran.T * (P_tran_2Layer + M_funnel_tran * Ve_funnel_tran.item()) * B_tran/H_function_funnel_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * epsilon_tran.T * (P_tran_2Layer + M_funnel_tran * Ve_funnel_tran.item()) * B_tran/H_function_funnel_tran
            K_hat_g_tran_dot = -Gamma_g_tran * e_tran * epsilon_tran.T * (P_tran_2Layer + M_funnel_tran * Ve_funnel_tran.item()) * B_tran/H_function_funnel_tran
     
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            xi_funnel_tran_temp = (u_max - u1)/max(u1 - u_min, Delta_u_min)
            xi_funnel_tran = (e_tran.T * Q_tran_2Layer * e_tran >= 2 * Ve_funnel_tran * eta_funnel_tran**2 * xi_funnel_tran_temp + nu_funnel_tran) * (H_function_funnel_tran > 0) * xi_funnel_tran_temp
            
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            H_function_funnel_rot = eta_max_funnel_rot - eta_funnel_rot**2 - e_rot.T * M_funnel_rot * e_rot
            Ve_funnel_rot = (epsilon_rot.T * P_rot_2Layer * epsilon_rot)/H_function_funnel_rot
            
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * epsilon_rot.T * (P_rot_2Layer + M_funnel_rot * Ve_funnel_rot.item()) * B_rot/H_function_funnel_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * epsilon_rot.T * (P_rot_2Layer + M_funnel_rot * Ve_funnel_rot.item()) * B_rot/H_function_funnel_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * epsilon_rot.T * (P_rot_2Layer + M_funnel_rot * Ve_funnel_rot.item()) * B_rot/H_function_funnel_rot
            K_hat_g_rot_dot = -Gamma_g_rot * e_rot * epsilon_rot.T * (P_rot_2Layer + M_funnel_rot * Ve_funnel_rot.item()) * B_rot/H_function_funnel_rot
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented + K_hat_g_rot.T * e_rot
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            xi_funnel_rot_temp = (Moment_max - LA.norm(Moment))/max(LA.norm(Moment) - Moment_min, Delta_Moment_min)
            xi_funnel_rot = (e_rot.T * Q_rot_2Layer * e_rot >= 2 * Ve_funnel_rot * eta_funnel_rot**2 * xi_funnel_rot_temp + nu_funnel_rot) * (H_function_funnel_rot > 0) * xi_funnel_rot_temp
            
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            dy[104:110] = e_transient_tran_dot
            dy[110:128] = K_hat_g_tran_dot.reshape(18,1)
            dy[128:131] = e_transient_rot_dot
            dy[131:140] = K_hat_g_rot_dot.reshape(9,1)
            dy[140] = eta_funnel_tran * xi_funnel_tran
            dy[141] = eta_funnel_rot * xi_funnel_rot
         
            return np.array(dy)
        
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------

        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        def MRACwithBASELINE_SafetyMechanism(t, y):
            """
            This function defines the system of equations of the MRAC with Baseline CONTROLLER that need to be integrated 
        
            """
            global mu_x, mu_y, mu_z, u1, roll_ref, pitch_ref, roll_ref_dot, pitch_ref_dot, roll_ref_ddot, pitch_ref_ddot, roll_ref_dot_fil, pitch_ref_dot_fil, roll_ref_ddot_fil, pitch_ref_ddot_fil
            global angular_position_ref_dot, angular_position_ref_ddot, Jacobian_matrix_inverse, angular_position_dot
            global angular_error_dot, u2, u3, u4, mu_baseline_tran, mu_adaptive_tran, Moment_baseline, Moment_adaptive
            global mu_PD_baseline_tran, Moment_baseline_PI, omega_ref_dot, omega_cmd, omega_cmd_dot, Jacobian_matrix
            global Jacobian_matrix_dot, angular_error
        
            
            state_phi_ref_diff = y[0:2] # State of the differentiator for phi_ref (roll_ref)
            state_theta_ref_diff = y[2:4] # State of the differentiator for theta_ref (pitch_ref)
            state_phi_ref_diff_fil = y[4:6] # State of the KF differentiator for phi_ref (roll_ref)
            state_theta_ref_diff_fil = y[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
            x_ref_tran = y[8:14] # Reference model state
            integral_position_tracking_ref = y[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
            K_hat_x_tran = y[17:35] # \hat{K}_x (translational)
            K_hat_r_tran = y[35:44] # \hat{K}_r (translational)
            Theta_hat_tran = y[44:62] # \hat{\Theta} (translational)
            omega_ref = y[62:65] # Reference model rotational dynamics
            K_hat_x_rot = y[65:74] # \hat{K}_x (rotational)
            K_hat_r_rot = y[74:83] # \hat{K}_r (rotational)
            Theta_hat_rot = y[83:101] # \hat{\Theta} (rotational)
            integral_e_rot = y[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
            
            integral_angular_error = y[104:107] # Integral of angular_error = attitude - attitude_ref
            integral_e_omega_ref_cmd = y[107:110] #Integral of (omega_ref - omega_cmd)
            
            K_hat_x_tran = np.matrix(K_hat_x_tran.reshape(6,3))
            K_hat_r_tran = np.matrix(K_hat_r_tran.reshape(3,3))
            Theta_hat_tran = np.matrix(Theta_hat_tran.reshape(6,3))
            K_hat_x_rot = np.matrix(K_hat_x_rot.reshape(3,3))
            K_hat_r_rot = np.matrix(K_hat_r_rot.reshape(3,3))
            Theta_hat_rot = np.matrix(Theta_hat_rot.reshape(6,3))
            
            
            e_tran = x_tran - x_ref_tran
            e_rot = angular_velocity - omega_ref
            translational_position_in_I_ref = x_ref_tran[0:3]
            
            R3 = np.matrix([[math.cos(yaw), -math.sin(yaw), 0],
                            [math.sin(yaw),  math.cos(yaw), 0],
                            [            0,              0, 1]])
            
            R2 = np.matrix([[ math.cos(pitch), 0, math.sin(pitch)],
                            [               0, 1,               0],
                            [-math.sin(pitch), 0, math.cos(pitch)]])
            
            R1 = np.matrix([[1,              0,               0],
                            [0, math.cos(roll), -math.sin(roll)],
                            [0, math.sin(roll),  math.cos(roll)]])
            
            R_from_loc_to_glob = R3*R2*R1
            R_from_glob_to_loc = R_from_loc_to_glob.transpose()
            
            Phi_adaptive_tran = -0.5 * LA.norm(R_from_glob_to_loc * translational_velocity_in_I) * (R_from_glob_to_loc * translational_velocity_in_I)
            
            Jacobian_matrix_inverse = np.matrix([[1, (math.sin(roll)*math.sin(pitch))/math.cos(pitch), (math.cos(roll)*math.sin(pitch))/math.cos(pitch)],
                                                  [0,                                   math.cos(roll),                                  -math.sin(roll)],
                                                  [0,                   math.sin(roll)/math.cos(pitch),                   math.cos(roll)/math.cos(pitch)]])
        
            angular_position_dot = Jacobian_matrix_inverse * angular_velocity # Time derivative of the Euler angles
            roll_dot = angular_position_dot[0] # phi_dot
            pitch_dot = angular_position_dot[1] # theta_dot
            # yaw_dot = angular_position_dot[2] # psi_dot
            
            Jacobian_matrix_dot = np.matrix(np.zeros((3,3)))
            Jacobian_matrix_dot[0,2] = -math.cos(pitch) * pitch_dot
            Jacobian_matrix_dot[1,1] = -math.sin(roll) * roll_dot
            Jacobian_matrix_dot[1,2] = math.cos(roll) * math.cos(pitch) * roll_dot - math.sin(roll) * math.sin(pitch) * pitch_dot
            Jacobian_matrix_dot[2,1] = -math.cos(roll) * roll_dot
            Jacobian_matrix_dot[2,2] = -math.cos(pitch) * math.sin(roll) * roll_dot - math.cos(roll) * math.sin(pitch) * pitch_dot
            
            r_tran = mass_total_estimated * (-KI_tran*integral_position_tracking_ref + translational_acceleration_in_I_user + KP_tran*translational_position_in_I_user + KD_tran*translational_velocity_in_I_user)
        
            x_ref_tran_dot = A_ref_tran*x_ref_tran + B_ref_tran*r_tran
            
            mu_PD_baseline_tran = -mass_total_estimated * (KP_tran_PD_baseline * (translational_position_in_I - translational_position_in_I_ref) + KD_tran_PD_baseline * (translational_velocity_in_I - x_ref_tran[3:6]) - x_ref_tran_dot[3:6])
            
            Phi_adaptive_tran_augmented = np.matrix(np.block([[mu_PD_baseline_tran],
                                                              [Phi_adaptive_tran]]))
            Theta_tran_adaptive_bar_augmented = np.matrix(np.block([[np.identity(3)],
                                                              [Theta_tran_adaptive_bar]]))
            
            mu_baseline_tran = K_x_tran_bar.T * x_tran + K_r_tran_bar.T * r_tran - Theta_tran_adaptive_bar_augmented.T * Phi_adaptive_tran_augmented
            mu_adaptive_tran = K_hat_x_tran.T * x_tran + K_hat_r_tran.T * r_tran - Theta_hat_tran.T * Phi_adaptive_tran_augmented
            mu_tran_raw = mu_PD_baseline_tran + mu_baseline_tran + mu_adaptive_tran
            
            K_hat_x_tran_dot = -Gamma_x_tran * x_tran * e_tran.T * P_tran * B_tran
            K_hat_r_tran_dot = -Gamma_r_tran * r_tran * e_tran.T * P_tran * B_tran
            Theta_hat_tran_dot = Gamma_Theta_tran * Phi_adaptive_tran_augmented * e_tran.T * P_tran * B_tran
        
            mu_x_raw = mu_tran_raw[0].item()
            mu_y_raw = mu_tran_raw[1].item()
            mu_z_raw = mu_tran_raw[2].item()
            #----------------
            # Safety Mechanism
            
            # Mu - sphere intersection
            tSphereVector = np.zeros((2,1))
            if LA.norm(mu_tran_raw) >= sphereEpsilon:
                tSphereVector[0] = (mu_z_raw*mass_total_estimated*G_acc + math.sqrt((mu_z_raw*mass_total_estimated*G_acc)**2 +
                                    LA.norm(mu_tran_raw)**2 * (maximumThrust**2 - (mass_total_estimated*G_acc)**2)))/LA.norm(mu_tran_raw)**2
                tSphereVector[1] = (mu_z_raw*mass_total_estimated*G_acc - math.sqrt((mu_z_raw*mass_total_estimated*G_acc)**2 +
                                    LA.norm(mu_tran_raw)**2 * (maximumThrust**2 - (mass_total_estimated*G_acc)**2)))/LA.norm(mu_tran_raw)**2
            else:
                tSphereVector[0] = math.nan
                tSphereVector[1] = math.nan
            
            # Mu - elliptic cone intersection
            tEllipticConeVector = np.zeros((2,1))
            if abs(mu_z_raw + math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 +
                                        (mu_y_raw/math.tan(maximumRollAngle))**2)) >= EllipticConeEpsilon:
                tEllipticConeVector[0] = (mass_total_estimated*G_acc)/(mu_z_raw + 
                                          math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 + (mu_y_raw/math.tan(maximumRollAngle))**2))
            else:
                tEllipticConeVector[0] = math.nan
                
            if abs(-mu_z_raw + math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 +
                                        (mu_y_raw/math.tan(maximumRollAngle))**2)) >= EllipticConeEpsilon:
                tEllipticConeVector[1] = -(mass_total_estimated*G_acc)/(-mu_z_raw + 
                                          math.sqrt((mu_x_raw/math.tan(maximumPitchAngle))**2 + (mu_y_raw/math.tan(maximumRollAngle))**2))
            else:
                tEllipticConeVector[1] = math.nan
                
            # Mu - plane intersection
            if abs(mu_z_raw) >= planeEpsilon:
                tPlane = alphaPlane*mass_total_estimated*G_acc/mu_z_raw
            else:
                tPlane = math.nan
                
            tVector = np.array([tSphereVector[0].item(),tSphereVector[1].item(),
                                tEllipticConeVector[0].item(),tEllipticConeVector[1].item(),tPlane])
            for i in range(0,tVector.size):
                if tVector[i] < 0:
                    tVector[i] = math.nan
                    
            tValue = min(tVector)
            
            if tValue > 1:
                tValue = 1
                
            mu_tran = tValue * mu_tran_raw
            mu_x = mu_tran[0].item()
            mu_y = mu_tran[1].item()
            mu_z = mu_tran[2].item()
            #----------------
            
            u1 = math.sqrt(mu_x ** 2 + mu_y ** 2 + (mass_total_estimated * G_acc - mu_z) ** 2)
            
            calculation_var_A = -(1/u1) * (mu_x * math.sin(yaw_ref) - mu_y * math.cos(yaw_ref))
            roll_ref = math.atan2(calculation_var_A, math.sqrt(1 - calculation_var_A ** 2))
            
            pitch_ref = math.atan2(-(mu_x * math.cos(yaw_ref) + mu_y * math.sin(yaw_ref)), (mass_total_estimated * G_acc - mu_z))
            
            internal_state_differentiator_phi_ref_diff = A_phi_ref * state_phi_ref_diff + B_phi_ref*roll_ref
            internal_state_differentiator_theta_ref_diff = A_theta_ref * state_theta_ref_diff + B_theta_ref*pitch_ref
            
            roll_ref_dot = np.asarray(C_phi_ref*state_phi_ref_diff).item()
            pitch_ref_dot = np.asarray(C_theta_ref*state_theta_ref_diff).item()
            
            roll_ref_ddot = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff).item()
            pitch_ref_ddot = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff).item()
            
            
            
            # Kalman Filter implemetation
            internal_state_differentiator_phi_ref_diff_fil = A_phi_ref * state_phi_ref_diff_fil + B_phi_ref*roll_ref + K_phi * (roll_ref_dot - np.asarray(C_phi_ref*state_phi_ref_diff_fil).item())
            internal_state_differentiator_theta_ref_diff_fil = A_theta_ref * state_theta_ref_diff_fil + B_theta_ref*pitch_ref + K_theta * (pitch_ref_dot - np.asarray(C_theta_ref*state_theta_ref_diff_fil).item())
            
            roll_ref_dot_fil = np.asarray(C_phi_ref*state_phi_ref_diff_fil).item()
            pitch_ref_dot_fil = np.asarray(C_theta_ref*state_theta_ref_diff_fil).item()
            
            roll_ref_ddot_fil = np.asarray(C_phi_ref*internal_state_differentiator_phi_ref_diff_fil).item()
            pitch_ref_ddot_fil = np.asarray(C_theta_ref*internal_state_differentiator_theta_ref_diff_fil).item()
            
            
            
            angular_position_ref_dot = np.array([roll_ref_dot_fil, pitch_ref_dot_fil, yaw_ref_dot]).reshape(3,1)
            angular_position_ref_ddot = np.array([roll_ref_ddot_fil, pitch_ref_ddot_fil, yaw_ref_ddot]).reshape(3,1)
        
            angular_error_dot = angular_position_dot - angular_position_ref_dot
            
            Jacobian_matrix = np.matrix([[1,               0,                 -math.sin(pitch)],
                                          [0,  math.cos(roll), math.sin(roll) * math.cos(pitch)],
                                          [0, -math.sin(roll), math.cos(roll) * math.cos(pitch)]])
            # print('HELLO Jacobian_matrix')
            # omega_cmd = Jacobian_matrix * (-KP_rot*angular_error + angular_position_ref_dot)
            # omega_cmd_dot = Jacobian_matrix_dot * (-KP_rot*angular_error + angular_position_ref_dot) + Jacobian_matrix * (-KP_rot*angular_error_dot + angular_position_ref_ddot)
            
            omega_cmd = Jacobian_matrix * (-KP_rot*angular_error 
                                           -KI_rot*integral_angular_error 
                                           + angular_position_ref_dot)
            omega_cmd_dot = (Jacobian_matrix_dot * (-KP_rot*angular_error 
                                                 -KI_rot*integral_angular_error 
                                                 + angular_position_ref_dot)
                          + Jacobian_matrix * (-KP_rot*angular_error_dot 
                                               -KI_rot*angular_error 
                                               + angular_position_ref_ddot))
            
            
            # omega_ref_dot = -K_P_omega_ref*(omega_ref - omega_cmd) + omega_cmd_dot
            
            # r_rot = K_P_omega_ref * omega_cmd + omega_cmd_dot
            
            omega_ref_dot = (-K_P_omega_ref*(omega_ref - omega_cmd) 
                              -K_I_omega_ref*integral_e_omega_ref_cmd
                              + omega_cmd_dot)
            
            r_rot = K_P_omega_ref * omega_cmd -K_I_omega_ref*integral_e_omega_ref_cmd + omega_cmd_dot
            
            Phi_adaptive_rot = np.array([[angular_velocity[1].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[2].item()],
                                          [angular_velocity[0].item() * angular_velocity[1].item()]])
            
            Moment_baseline_PI = -I_matrix_estimated * (KP_rot_PI_baseline*e_rot + KI_rot_PI_baseline*integral_e_rot - omega_ref_dot)
            
            Phi_adaptive_rot_augmented = np.matrix(np.block([[Moment_baseline_PI],
                                                              [Phi_adaptive_rot]]))
            
            K_hat_x_rot_dot = -Gamma_x_rot * angular_velocity * e_rot.T * P_rot * B_rot
            K_hat_r_rot_dot = -Gamma_r_rot * r_rot * e_rot.T * P_rot * B_rot
            Theta_hat_rot_dot = Gamma_Theta_rot * Phi_adaptive_rot_augmented * e_rot.T * P_rot * B_rot
            
            Moment_baseline = np.cross(angular_velocity.ravel(), (I_matrix_estimated * angular_velocity).ravel()).reshape(3,1)
            Moment_adaptive = K_hat_x_rot.T * angular_velocity + K_hat_r_rot.T * r_rot - Theta_hat_rot.T * Phi_adaptive_rot_augmented
            
            Moment = Moment_baseline_PI + Moment_baseline + Moment_adaptive
            
            u2 = Moment[0].item()
            u3 = Moment[1].item()
            u4 = Moment[2].item()
            
            
            dy[0:2] = internal_state_differentiator_phi_ref_diff
            dy[2:4] = internal_state_differentiator_theta_ref_diff
            dy[4:6] = internal_state_differentiator_phi_ref_diff_fil
            dy[6:8] = internal_state_differentiator_theta_ref_diff_fil
            dy[8:14] = x_ref_tran_dot
            dy[14:17] = translational_position_in_I_ref - translational_position_in_I_user
            dy[17:35] = K_hat_x_tran_dot.reshape(18,1)
            dy[35:44] = K_hat_r_tran_dot.reshape(9,1)
            dy[44:62] = Theta_hat_tran_dot.reshape(18,1)
            dy[62:65] = omega_ref_dot
            dy[65:74] = K_hat_x_rot_dot.reshape(9,1)
            dy[74:83] = K_hat_r_rot_dot.reshape(9,1)
            dy[83:101] = Theta_hat_rot_dot.reshape(18,1)
            dy[101:104] = angular_velocity - omega_ref
            
            dy[104:107] = angular_error
            dy[107:110] = omega_ref - omega_cmd
         
            return np.array(dy)
        
    #     # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
    my_frame_pos_GLOB = my_frame.GetPos()

    #%% Irrlicht visualization
    if visualization_flag == True:    
        #******************************************************************************    
        # Create the Irrlicht visualization
        vis = irr.ChVisualSystemIrrlicht()
        vis.AttachSystem(my_system)
        # vis.SetWindowSize(1024,768)
        vis.SetWindowSize(1536,1152)
        vis.SetWindowTitle('X8-Copter - Controller: ' + controller_type)
        vis.Initialize()
        vis.AddLogo(chrono.GetChronoDataPath() + 'logo_pychrono_alpha.png')
        vis.AddSkyBox()
        # vis.AddCamera(chrono.ChVectorD(2.5, 1.5, 0.5)) #(1,1,1) - (2.5,1.5,0.5) FIXED CAMERA
        vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
        # vis.AddCamera(chrono.ChVectorD(6,1.5,3), chrono.ChVectorD(3,0,-2))
        # vis.AddCamera(chrono.ChVectorD(2, 1, 3), chrono.ChVectorD(2,0.5,1.5))
        vis.AddTypicalLights()
        # vis.AddLightWithShadow(chrono.ChVectorD(3,6,2),    # point
        #                               chrono.ChVectorD(0,0,0),    # aimpoint
        #                               12,                 # radius (power)
        #                               1,11,              # near, far
        #                               55)                # angle of FOV
        vis.AddLightWithShadow(chrono.ChVectorD(0,5,0),    # point
                                      chrono.ChVectorD(3,2,0),    # aimpoint
                                      5,                 # radius (power)
                                      1,8,              # near, far
                                      55)                # angle of FOV
        vis.BindAll()
    #******************************************************************************    

    #------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    # Inizialization of arrays/lists to store data
    
    my_frame_pos_GLOB = my_frame.GetPos() # Do this if you want to print the position value of the drone frame to monitor
    my_frame_quat = my_frame.GetRot()
    my_ball1_pos = my_ball1.GetPos()
    my_ball2_pos = my_ball2.GetPos()
    
    
    
    
    times=[] # Array to store times
    
    # List to store xyz position of the drone frame - Do this if you want to append the information to a list
    my_frame_pos_GLOB_list = [['Time [s]','Drone Frame X position [m]', 'Drone Frame Y position [m]', 'Drone Frame Z position [m]']] 
    
    # GLOBAL COORDINATES of PIXHAWK, List to store xyz position and quaternion(e0,e1,e2,e3) of the pixhawk,
    # its velocity and angular velocity, its acceleration and angular acceleration
    state_pixhawk_GLOB = [['Time [s]','Pixhawk X position [m]', 'Pixhawk Y position [m]', 'Pixhawk Z position [m]',
                          'Pixhawk e0 quaternion term [-]', 'Pixhawk e1 quaternion term [-]', 'Pixhawk e2 quaternion term [-]', 'Pixhawk e3 quaternion term [-]',
                          'Pixhawk X velocity [m/s]', 'Pixhawk Y velocity [m/s]', 'Pixhawk Z velocity [m/s]',
                          'Pixhawk angular velocity wrt X axis [rad/s]', 'Pixhawk angular velocity wrt Y axis [rad/s]', 'Pixhawk angular velocity wrt Z axis [rad/s]',
                          'Pixhawk X acceleration [m/s^2]', 'Pixhawk Y acceleration [m/s^2]', 'Pixhawk Z acceleration [m/s^2]',
                          'Pixhawk angular acceleration wrt X axis [rad/s^2]', 'Pixhawk angular acceleration wrt Y axis [rad/s^2]', 'Pixhawk angular acceleration wrt Z axis [rad/s^2]']]
    
    # LOCAL COORDINATES of PIXHAWK, List to store of the pixhawk,
    # its velocity and angular velocity, its acceleration and angular acceleration
    state_pixhawk_LOC = [['Time [s]', 'Pixhawk X velocity [m/s]', 'Pixhawk Y velocity [m/s]', 'Pixhawk Z velocity [m/s]',
                          'Pixhawk angular velocity wrt X axis [rad/s]', 'Pixhawk angular velocity wrt Y axis [rad/s]', 'Pixhawk angular velocity wrt Z axis [rad/s]',
                          'Pixhawk X acceleration [m/s^2]', 'Pixhawk Y acceleration [m/s^2]', 'Pixhawk Z acceleration [m/s^2]',
                          'Pixhawk angular acceleration wrt X axis [rad/s^2]', 'Pixhawk angular acceleration wrt Y axis [rad/s^2]', 'Pixhawk angular acceleration wrt Z axis [rad/s^2]']]
    
    # GLOBAL and LOCAL rotational acceleration of the drone frame
    my_frame_Wacc_list = [['Time [s]','Drone Frame GLOBAL angular acceleration wrt X axis [rad/s^2]', 'Drone Frame GLOBAL angular acceleration wrt Y axis [rad/s^2]', 'Drone Frame GLOBAL angular acceleration wrt Z axis [rad/s^2]',
                           'Drone Frame LOCAL angular acceleration wrt X axis [rad/s^2]', 'Drone Frame LOCAL angular acceleration wrt Y axis [rad/s^2]', 'Drone Frame LOCAL angular acceleration wrt Z axis [rad/s^2]']]
    
    # List to store xyz position of Ball_1, Ball_2, COG_total_box in LOCAL COORDINATES seen from the BOX REFERENCE SYSTEM
    my_ball_pos_LOC_list = [['Time [s]','Ball_1 X position [m]', 'Ball_1 Y position [m]', 'Ball_1 Z position [m]',
                             'Ball_2 X position [m]', 'Ball_2 Y position [m]', 'Ball_2 Z position [m]',
                             'COG X position [m]', 'COG Y position [m]', 'COG Z position [m]']]
    
    # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk
    # ACTUALLY IT LOOKS LIKE (ROLL, YAW, PITCH)
    pixhawk_euler_list = [['Time [s]','Pixhawk roll [rad]', 'Pixhawk pitch [rad]', 'Pixhawk yaw [rad]']]
    
    COG_total_list = [['Time [s]','COG X position [m]', 'COG Y position [m]', 'COG Z position [m]']]
    
    COG_list = [['Time [s]','COG X position [m]', 'COG Y position [m]', 'COG Z position [m]']]
    
    # List to store xyz components of the contact force of Ball_1 and Ball_2 in GLOBAL COORDINATES 
    my_ball_cfr_list = [['Time [s]','Ball1 X contact force [N]', 'Ball1 Y contact force [N]', 'Ball1 Z contact force [N]',
                         'Ball2 X contact force [N]', 'Ball2 Y contact force [N]', 'Ball2 Z contact force [N]']]
    
    # List to store angular velocities of the motors
    omega_8_list = [['Time [s]', 'Motor 1 ang. vel. [rad/s]', 'Motor 2 ang. vel. [rad/s]', 'Motor 3 ang. vel. [rad/s]', 'Motor 4 ang. vel. [rad/s]',
                     'Motor 5 ang. vel. [rad/s]', 'Motor 6 ang. vel. [rad/s]', 'Motor 7 ang. vel. [rad/s]', 'Motor 8 ang. vel. [rad/s]']]
    
    pos_pixhawk_LOC_to_GLOB_list = [['Time [s]','Pixhawk X position [m]', 'Pixhawk Y position [m]', 'Pixhawk Z position [m]']]
    
    pos_pixhawk_LOC_to_GLOB_NED_list = [['Time [s]','Pixhawk X position [m]', 'Pixhawk Y position [m]', 'Pixhawk Z position [m]']]
    
    torque_list = [['Time [s]', 'Torque Motor 1 [Nm]', 'Torque Motor 2 [Nm]', 'Torque Motor 3 [Nm]', 'Torque Motor 4 [Nm]',
                    'Torque Motor 5 [Nm]', 'Torque Motor 6 [Nm]', 'Torque Motor 7 [Nm]', 'Torque Motor 8 [Nm]']]
    
    T_list = [['Time [s]', 'Thrust Motor 1 [N]', 'Thrust Motor 2 [N]', 'Thrust Motor 3 [N]', 'Thrust Motor 4 [N]',
                    'Thrust Motor 5 [N]', 'Thrust Motor 6 [N]', 'Thrust Motor 7 [N]', 'Thrust Motor 8 [N]']]
    
    DATA = np.zeros((size_DATA,1))
    
    # # Collision report
    # my_rep = MyReportContactCallback()
    # controller_z_output = 0
    #--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    
    date = datetime.datetime.now()
    
    start_simulation_time = time.time() # Time acquired in order to measure the execution time of the simulation
    

    # Simulation loop
    while my_system.GetChTime()<max_simulation_time:
    #****************************************************************************** 
   # while vis.Run():
        if visualization_flag == True:
            vis.BeginScene()
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(0.5, -0.3, -0.4), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(0.2, 0.3, -0.6), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(-0.6, 0.9, -1.8), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(1.2, 0.9, -0.9), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(1.2, 0.9, 0.9), my_frame_pos_GLOB) # MOVING CAMERA (1.5, 1, 1)
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(-0.8, 0.1, 0), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            
            # vis.AddCamera(my_frame_pos_GLOB + chrono.ChVectorD(2, 0.2, 1), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(2, 2, -1), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB) # MOVING CAMERA (-0.5, 0.2, 0)
            
            # if my_system.GetChTime() < 6:
            #     vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
            
            # if my_system.GetChTime() >= 6 and my_system.GetChTime() < 7:
            #     vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(1.5, 2, -1.5), my_frame_pos_GLOB)
            
            # vis.AddCamera(chrono.ChVectorD(my_frame_pos_GLOB.x, 0, my_frame_pos_GLOB.z) + chrono.ChVectorD(-1.5, 2, 1.5), my_frame_pos_GLOB)
            
            # Camera fixed with drone orientation
            # if my_system.GetChTime() > 0.1:
            #     # vis.AddCamera(pixhawk_rotmat*(pos_pixhawk_LOC + chrono.ChVectorD(-0.55, 0, -0.1)), my_frame_pos_GLOB + chrono.ChVectorD(0, 0.05, 0)) # MOVING CAMERA
            #     vis.AddCamera(pixhawk_rotmat*(pos_pixhawk_LOC + chrono.ChVectorD(-0.4, 0, -0.1)), my_frame_pos_GLOB + chrono.ChVectorD(0, 0.05, 0)) # MOVING CAMERA 
                
            
            vis.Render()
            irr.drawCoordsys(vis, marker_pixhawk.GetAbsCoord(), 0.5) # Draw the coordinate system of pixhawk (NED) during the simulation
            # irr.drawCoordsys(vis, marker_pixhawk_2.GetAbsCoord(), 0.5) # Draw the coordinate system of pixhawk (Y up) during the simulation
            # irr.drawCoordsys(vis, pixhawk_csys_fixed, 4) # Draw the fixed coordinate system of pixhawk during the simulation
            # irr.drawCoordsys(vis, marker_ball3.GetAbsCoord(), 0.5) # Draw the coordinate system of ball3 during the simulation
            irr.drawCoordsys(vis, global_coord, 1) # Draw the Global coordinate system during the simulation
            # irr.drawCoordsys(vis, my_ball1_csys, 0.3) #Draw the csys of ball1
            # irr.drawCoordsys(vis, my_prop1.GetCoord(), 0.3) #Draw the csys of propeller 1
            # irr.drawCoordsys(vis, my_ball2_csys, 0.3) #Draw the csys of ball2
            # irr.drawAllCOGs(vis,0.05) # Draw the Center Of Gravity of all bodies
            vis.EndScene()
        #******************************************************************************    
        
            if not vis.Run():
                break
        my_system.DoStepDynamics(m_timestep)
        
        my_frame.Empty_forces_accumulators() # Command that MUST be used in conjunction with Accumulate_force() and Accumulate_torque() used below
        
        # # Collision report -------------------------------------------------------------------------------------
        # my_rep.ResetList()
        # my_system.GetContactContainer().ReportAllContacts(my_rep)
        # crt_list = my_rep.GetList()
        # print('time=', my_system.GetChTime(), ' num. contacts=', my_system.GetContactContainer().GetNcontacts())
        # print(*crt_list, sep='\n')
        # # ------------------------------------------------------------------------------------------------------
        
        ##################################################################################################################################################################################
             
        ################ Build lists to export data ################
        time_now = my_system.GetChTime() # Time "inside" the simulation
        times.append(time_now)
        
        simulation_time = time.time() - start_simulation_time # Time that the simulation is taking
        
        # Global coordinates of the origin of the drone frame containing just the position
        my_frame_pos_GLOB = my_frame.GetPos() 
        my_frame_pos_GLOB_list.append([time_now, chvector_to_list(my_frame_pos_GLOB)[0], chvector_to_list(my_frame_pos_GLOB)[1], chvector_to_list(my_frame_pos_GLOB)[2]])
    
    
    
        # GLOBAL COORDINATES of PIXHAWK---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        coord_pixhawk_GLOB = marker_pixhawk.GetAbsCoord() # Global coordinates of the pixhawk containing both its position and rotation (quaternion)
        coord_dt_pixhawk_GLOB = marker_pixhawk.GetAbsCoord_dt() # Global velocities of the pixhawk derived from its position and rotation (quaternion)
        coord_dtdt_pixhawk_GLOB = marker_pixhawk.GetAbsCoord_dtdt() # Global accelerations of the pixhawk derived from its position and rotation (quaternion)
        Wvel_pixhawk_GLOB = marker_pixhawk.GetAbsWvel() # Angular velocity of the pixhawk respect to global coordinates, expressed in global coordinates
        Wacc_pixhawk_GLOB = marker_pixhawk.GetAbsWacc() # Angular acceleration of the pixhawk respect to global coordinates, expressed in global coordinates
        state_pixhawk_GLOB.append([time_now, chcoordsys_to_list(coord_pixhawk_GLOB)[0][0], chcoordsys_to_list(coord_pixhawk_GLOB)[0][1], chcoordsys_to_list(coord_pixhawk_GLOB)[0][2],
                                  chcoordsys_to_list(coord_pixhawk_GLOB)[1][0], chcoordsys_to_list(coord_pixhawk_GLOB)[1][1], chcoordsys_to_list(coord_pixhawk_GLOB)[1][2], chcoordsys_to_list(coord_pixhawk_GLOB)[1][3],
                                  chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0][0], chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0][1], chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0][2],
                                  chvector_to_list(Wvel_pixhawk_GLOB)[0], chvector_to_list(Wvel_pixhawk_GLOB)[1], chvector_to_list(Wvel_pixhawk_GLOB)[2],
                                  chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0][0], chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0][1], chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0][2],
                                  chvector_to_list(Wacc_pixhawk_GLOB)[0], chvector_to_list(Wacc_pixhawk_GLOB)[1], chvector_to_list(Wacc_pixhawk_GLOB)[2]])
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        
        
        # LOCAL COORDINATES of PIXHAWK---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        pixhawk_rotmat = chrono.ChMatrix33D(coord_pixhawk_GLOB.rot) # rotation matrix of the pixhawk given by pychrono (computed using pixhawk quaternion expressed in glob coord)
        pixhawk_rotmat_array = np.asarray(pixhawk_rotmat.GetMatr())
        
        pixhawk_rotmat_F = rotmat_fromQ_Glob_to_Loc_asChMatrix33(coord_pixhawk_GLOB.rot) # rotation matrix of the pixhawk to go from Global to Local coordinates (computed using Mattia's function: rotmat_fromQ_Glob_to_Loc_asarray)
        pixhawk_rotmat_F_array = np.asarray(pixhawk_rotmat_F.GetMatr())
        
        # pixhawk_rotmat_T_array = np.transpose(np.asarray(pixhawk_rotmat.GetMatr())) # TRANSPOSED rotation matrix of the pixhawk given by pychrono (computed using pixhawk quaternion expressed in glob coord)
        # pixhawk_rotmat_T = chrono.ChMatrix33D()
        # pixhawk_rotmat_T.SetMatr(pixhawk_rotmat_T_array)
        
        pixhawk_csys_fixed_rotmat_array = rotmat_fromQ_Glob_to_Loc_asarray(pixhawk_csys_fixed.rot)
        pixhawk_csys_fixed_rotmat = rotmat_fromQ_Glob_to_Loc_asChMatrix33(pixhawk_csys_fixed.rot)
        pixhawk_csys_fixed_rotmat_array_transposed = np.transpose(pixhawk_csys_fixed_rotmat_array)
        
        rotmat_from_pixhawk_fixed_to_pixhawk = np.matmul(pixhawk_rotmat_F_array,pixhawk_csys_fixed_rotmat_array_transposed)
        
        
        pos_pixhawk_LOC = pixhawk_rotmat_F * coord_pixhawk_GLOB.pos # Local position of the pixhawk
        vel_pixhawk_LOC = pixhawk_rotmat_F * coord_dt_pixhawk_GLOB.pos # Local velocities of the pixhawk
        acc_pixhawk_LOC = pixhawk_rotmat_F * coord_dtdt_pixhawk_GLOB.pos # Local accelerations of the pixhawk 
        Wvel_pixhawk_LOC = pixhawk_rotmat_F * Wvel_pixhawk_GLOB # Local Angular velocity of the pixhawk 
        Wacc_pixhawk_LOC = pixhawk_rotmat_F * Wacc_pixhawk_GLOB # Local Angular acceleration of the pixhawk 
        state_pixhawk_LOC.append([time_now, chvector_to_list(vel_pixhawk_LOC)[0], chvector_to_list(vel_pixhawk_LOC)[1], chvector_to_list(vel_pixhawk_LOC)[2],
                                  chvector_to_list(Wvel_pixhawk_LOC)[0], chvector_to_list(Wvel_pixhawk_LOC)[1], chvector_to_list(Wvel_pixhawk_LOC)[2],
                                  chvector_to_list(acc_pixhawk_LOC)[0], chvector_to_list(acc_pixhawk_LOC)[1], chvector_to_list(acc_pixhawk_LOC)[2],
                                  chvector_to_list(Wacc_pixhawk_LOC)[0], chvector_to_list(Wacc_pixhawk_LOC)[1], chvector_to_list(Wacc_pixhawk_LOC)[2]])
        
        pos_pixhawk_LOC_to_GLOB = pixhawk_rotmat * pos_pixhawk_LOC # Global position of pixhawk obtained starting from the Local position and premultiplying times the rotation matrix
        pos_pixhawk_LOC_to_GLOB_NED = RR * pos_pixhawk_LOC_to_GLOB # Global position of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        pos_pixhawk_LOC_to_GLOB_list.append([time_now, chvector_to_list(pos_pixhawk_LOC_to_GLOB)[0], chvector_to_list(pos_pixhawk_LOC_to_GLOB)[1], chvector_to_list(pos_pixhawk_LOC_to_GLOB)[2]])
        pos_pixhawk_LOC_to_GLOB_NED_list.append([time_now, chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)[0], chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)[1], chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)[2]])
        vel_pixhawk_LOC_to_GLOB = pixhawk_rotmat * vel_pixhawk_LOC # Global velocity of pixhawk obtained starting from the Local velocity and premultiplying times the rotation matrix
        vel_pixhawk_LOC_to_GLOB_NED = RR * vel_pixhawk_LOC_to_GLOB # Global velocity of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        Wvel_pixhawk_LOC_to_GLOB = pixhawk_rotmat * Wvel_pixhawk_LOC # Global angular velocity of pixhawk obtained starting from the Local position and premultiplying times the rotation matrix
        Wvel_pixhawk_LOC_to_GLOB_NED = RR * Wvel_pixhawk_LOC_to_GLOB # Global angular velocity of pixhawk in NED convention obtained starting from the Local position and premultiplying times the rotation matrix
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        # Computing Center Of Mass (COM) of the system: drone frame + box + propellers + balls
        
        # Compute the position (in global coordinates) of the bodies
        # my_box_ref = my_box.GetFrame_REF_to_abs().GetCoord().pos # this gives the position of the auxillary csys imported from/defined in SolidWorks
        my_box_pos = my_box.GetFrame_COG_to_abs().GetCoord().pos # = same as asking for .GetPos() --> meaning GetPos() refers to the COG position!!!!
        my_prop1_pos = my_prop1.GetPos()
        my_prop2_pos = my_prop2.GetPos()
        my_prop3_pos = my_prop3.GetPos()
        my_prop4_pos = my_prop4.GetPos()
        my_prop5_pos = my_prop5.GetPos()
        my_prop6_pos = my_prop6.GetPos()
        my_prop7_pos = my_prop7.GetPos()
        my_prop8_pos = my_prop8.GetPos()
        
        # Compute the COG in Global Coordinates
        # (First you must put the ChVector (position) and then you can multiply it by a float (mass). Order is important!!!)
        COG_total = (my_frame_pos_GLOB * my_frame_mass + my_box_pos * my_box_mass + 
                    (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos + my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos)*8*(my_prop_mass) + 
                    my_ball1_pos * my_ball1_mass + my_ball2_pos * my_ball2_mass)*(1/mass_total_wballs)
        
        COG_total_list.append([time_now, chvector_to_list(COG_total)[0], chvector_to_list(COG_total)[1], chvector_to_list(COG_total)[2]])
        
        COG = (my_frame_pos_GLOB * my_frame_mass + my_box_pos * my_box_mass + 
              (my_prop1_pos + my_prop2_pos + my_prop3_pos + my_prop4_pos + my_prop5_pos + my_prop6_pos + my_prop7_pos + my_prop8_pos)*8*(my_prop_mass)) *(1/mass_total)
        
        COG_list.append([time_now, chvector_to_list(COG)[0], chvector_to_list(COG)[1], chvector_to_list(COG)[2]])
        
        my_COG_local = my_frame_csys.TransformParentToLocal(COG) # Position of COG seen from the local reference system of the frame
        
        #---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        
        # Ball position seen from Box refrence system
        my_ball1_pos_box = my_box_csys.TransformParentToLocal(my_ball1_pos) # Position of Ball1 seen from the local reference system of the Box
        my_ball2_pos_box = my_box_csys.TransformParentToLocal(my_ball2_pos) # Position of Ball1 seen from the local reference system of the Box
        COG_total_box = my_box_csys.TransformParentToLocal(COG_total) # Position of COG_total seen from the local reference system of the Box
        my_ball_pos_LOC_list.append([time_now, chvector_to_list(my_ball1_pos_box)[0], chvector_to_list(my_ball1_pos_box)[1], chvector_to_list(my_ball1_pos_box)[2],
                                     chvector_to_list(my_ball2_pos_box)[0], chvector_to_list(my_ball2_pos_box)[1], chvector_to_list(my_ball2_pos_box)[2],
                                     chvector_to_list(COG_total_box)[0], chvector_to_list(COG_total_box)[1], chvector_to_list(COG_total_box)[2]])
        
        
        
        # # Local velocity of ball3
        # my_ball3_rotmat = my_ball3.GetA() # rotation matrix of ball3
        # coord_dt_ball3_LOC = my_ball3_rotmat * my_ball3.GetCoord_dt().pos # Local velocity of ball3
        
        # # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk
        # pixhawk_euler_list.append([time_now, chvector_to_list(euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot))[0], chvector_to_list(euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot))[1], chvector_to_list(euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot))[2]])
        # # pixhawk_euler = euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot)
        # pixhawk_euler = euler321_fromQ_asChVector(coord_pixhawk_GLOB.rot) # ROLL YAW PITCH, at rest set at (90,0,0) degrees
        # pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        
        # # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk ALA METHOD
        # # quat_pixhawk = marker_pixhawk_2.GetAbsCoord().rot
        # quat_pixhawk = marker_pixhawk.GetAbsCoord().rot
        # quat_pixhawk_e0 = quat_pixhawk.e0
        # quat_pixhawk_e1 = -quat_pixhawk.e1
        # quat_pixhawk_e2 = quat_pixhawk.e2
        # quat_pixhawk_e3 = -quat_pixhawk.e3
        # quat_pixhawk_new = chrono.ChQuaternionD(quat_pixhawk_e0, quat_pixhawk_e1, quat_pixhawk_e3, quat_pixhawk_e2) #pixhawk quaternion with y and z components flipped
        
        # ==========================================================================================================================================================================
        # Rotation 321 sequence of euler angle (roll, pitch, yaw) of pixhawk ALA METHOD - CORRECT - 
        quat_pixhawk = marker_pixhawk_2.GetAbsCoord().rot
        quat_pixhawk_e0 = quat_pixhawk.e0
        quat_pixhawk_e1 = -quat_pixhawk.e1
        quat_pixhawk_e2 = quat_pixhawk.e2
        quat_pixhawk_e3 = -quat_pixhawk.e3
        quat_pixhawk_new = chrono.ChQuaternionD(quat_pixhawk_e0, quat_pixhawk_e1, quat_pixhawk_e3, quat_pixhawk_e2) #pixhawk quaternion with y and z components flipped
        
        pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_pixhawk_new)
        pixhawk_euler = euler321_from_rotmat(pixhawk_rotmat_2)
        pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        
        # ==========================================================================================================================================================================
        
        # # pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(marker_pixhawk_2.GetAbsCoord().rot)
        # pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_pixhawk_new)
        # # # pixhawk_rotmat_2 = rotmat_fromQ_Glob_to_Loc_asChMatrix33(quat_pixhawk)
        # pixhawk_euler = euler321_from_rotmat(pixhawk_rotmat_2)
        # # pixhawk_euler = euler321_fromQ_asChVector(quat_pixhawk_new) # ROLL YAW PITCH, at rest set at (90,0,0) degrees
        # pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        
        
        # pixhawk_euler = euler321_from_rotmat_matlab(pixhawk_rotmat)
        # pixhawk_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler))[2])]
        # pixhawk_euler_opposite = euler321_from_rotmat_matlab_opposite_direction(pixhawk_rotmat)
        # pixhawk_euler_opposite_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(pixhawk_euler_opposite))[0]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler_opposite))[1]), '%.3f'%(chvector_to_list(rad2deg(pixhawk_euler_opposite))[2])]
        
        
        # ball3_rotmat = chrono.ChMatrix33D(marker_ball3.GetAbsCoord().rot)
        # ball3_euler = euler321_from_rotmat_matlab(ball3_rotmat)
        # ball3_euler_deg_trunc = ['%.3f'%(chvector_to_list(rad2deg(ball3_euler))[0]), '%.3f'%(chvector_to_list(rad2deg(ball3_euler))[1]), '%.3f'%(chvector_to_list(rad2deg(ball3_euler))[2])]
        
        
        # ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            
        if trajectory_type == 'circular_trajectory':
            # Circular trajectory at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = circular_trajectory.user_defined_trajectory(time_now - controller_start_time, radius_trajectory, angular_velocity_trajectory, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = circular_trajectory.user_defined_yaw(time_now - controller_start_time, angular_velocity_trajectory)
              
        elif trajectory_type == 'hover_trajectory':
            # Hover trajectory at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = hover_trajectory.user_defined_trajectory(time_now - controller_start_time, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = hover_trajectory.user_defined_yaw(time_now - controller_start_time)
    
        elif trajectory_type == 'square_trajectory':
            # Square trajectory at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = square_trajectory.user_defined_trajectory(time_now - controller_start_time, square_side_size, linear_velocity_trajectory, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = square_trajectory.user_defined_yaw(time_now - controller_start_time, square_side_size, linear_velocity_trajectory)
        
        elif trajectory_type == 'roundedRectangle_trajectory':
            # Rounded rectangle at constant altitude
            [translational_position_in_I_user, translational_velocity_in_I_user, translational_acceleration_in_I_user] = roundedRectangle_trajectory.user_defined_trajectory(time_now - controller_start_time, length_horizontal, length_vertical, rounding_radius, linear_velocity_trajectory, altitude_trajectory)
            [yaw_ref, yaw_ref_dot, yaw_ref_ddot] = roundedRectangle_trajectory.user_defined_yaw(time_now - controller_start_time, length_horizontal, length_vertical, rounding_radius, linear_velocity_trajectory, altitude_trajectory)
        
        elif trajectory_type == 'piecewisePolynomial_trajectory':
            [translational_position_in_I_user,
             translational_velocity_in_I_user,
             translational_acceleration_in_I_user] = (trajectory_instance.
                     user_defined_trajectory(time_now - controller_start_time))
            [yaw_ref,
             yaw_ref_dot,
             yaw_ref_ddot] = trajectory_instance.user_defined_yaw()
          
        roll = pixhawk_euler.x
        pitch = pixhawk_euler.y
        yaw = pixhawk_euler.z
        translational_position_in_I = np.array(chvector_to_list(pos_pixhawk_LOC_to_GLOB_NED)).reshape(3,1)
        translational_velocity_in_I = np.array(chvector_to_list(vel_pixhawk_LOC_to_GLOB_NED)).reshape(3,1)
        translational_position_error = translational_position_in_I - translational_position_in_I_user
        angular_error = np.array([roll - roll_ref, pitch - pitch_ref, (((yaw - yaw_ref + PI) % (2*PI)) - PI)]).reshape(3,1)
        angular_velocity = np.array(chvector_to_list(Wvel_pixhawk_LOC)).reshape(3,1)
        angular_acceleration = np.array(chvector_to_list(Wacc_pixhawk_LOC)).reshape(3,1)
        x_tran = np.append(translational_position_in_I, translational_velocity_in_I, axis=0)
        
        
        ################## 
        # Applying AERODYNAMIC FORCE to the drone
        aerodynamic_velocity = np.array(chvector_to_list(vel_pixhawk_LOC)).reshape(3,1)
        aerodynamic_force = -0.5 * air_density_estimated * surface_area_estimated * drag_coefficient_matrix_estimated * aerodynamic_velocity * LA.norm(aerodynamic_velocity)
        my_frame.Accumulate_force(chrono.ChVectorD(aerodynamic_force[0].item(),aerodynamic_force[1].item(),aerodynamic_force[2].item()),chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05),True)
        
        # Applying a constant WIND FORCE to the drone, expressed in pychrono global coordinate
        # my_frame.Accumulate_force(chrono.ChVectorD(1,0,0),chrono.ChVectorD(-0.006329836449057219, -0.05730872796244302, 3.945863912075595e-05),False)
        
        ##################
        if Wrapper_execution == True:
            with open(csv_file_path, mode='w', newline='') as csv_file_wrapper:
                csv_writer = csv.writer(csv_file_wrapper)
                date = datetime.datetime.now(pytz.timezone('America/New_York'))
                introductory_fields = [["Execution Date:", str(date.month) +"-" + str(date.day) +"-" + str(date.year) ,"", "Simulation start time [s]:", str(date.hour)+":"+ str(date.minute)+":"+ str(date.second)], 
                                       ["Controller type:", controller_type ,"","Trajectory:", trajectory_type],
                                       ["Wrapper parameter:", "Ball density:", my_ball_density]]
                csv_writer.writerows(introductory_fields)
                if controller_type == "PID":
                    header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                                         "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                                         "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]", "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                                         "roll_ref_dot[rad/s]", "roll_ref_dot_fil[rad/s]", "pitch_ref_dot[rad/s]", "pitch_ref_dot_fil[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "roll_ref_ddot_fil[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "pitch_ref_ddot_fil[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                                         "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                                         "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                                         "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                                        "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]"]
                
                else:   
                    # header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                    #                      "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                    #                      "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]",
                    #                      "x_ref_tran1[m]", "x_ref_tran2[m]", "x_ref_tran3[m]", "x_ref_tran4[m]", "x_ref_tran5[m]", "x_ref_tran6[m]",
                    #                      "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                    #                      "roll_ref_dot[rad/s]", "pitch_ref_dot[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                    #                      "omega_ref_x[rad/s]", "omega_ref_y[rad/s]", "omega_ref_z[rad/s]", "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                    #                      "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                    #                      "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                    #                      "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]",
                    #                      "mu_baseline_tran_x[N]", "mu_baseline_tran_y[N]", "mu_baseline_tran_z[N]", 
                    #                      "mu_adaptive_tran_x[N]", "mu_adaptive_tran_y[N]", "mu_adaptive_tran_z[N]","mu_PD_baseline_tran_x[N]", "mu_PD_baseline_tran_y[N]", "mu_PD_baseline_tran_z[N]",
                    #                      "Moment_baseline_x[Nm]", "Moment_baseline_y[Nm]", "Moment_baseline_z[Nm]","Moment_adaptive_x[Nm]", "Moment_adaptive_y[Nm]", "Moment_adaptive_z[Nm]",
                    #                      "Moment_baseline_PI_x[Nm]", "Moment_baseline_PI_y[Nm]", "Moment_baseline_PI_z[Nm]"]
                    header_csv = ["Real Time[s]","Simulation time[s]", "translational_position_in_Ix[m]","translational_position_in_Iy[m]","translational_position_in_Iz[m]",
                                  "translational_velocity_in_Ix[m/s]","translational_velocity_in_Iy[m/s]","translational_velocity_in_Iz[m/s]", "roll[rad]","pitch[rad]","yaw[rad]",
                                  "angular_velocity_x[rad/s]","angular_velocity_y[rad/s]","angular_velocity_z[rad/s]",
                                  "x_ref_tran1[m]", "x_ref_tran2[m]", "x_ref_tran3[m]", "x_ref_tran4[m]", "x_ref_tran5[m]", "x_ref_tran6[m]",
                                  "roll_ref[rad]","pitch_ref[rad]", "yaw_ref[rad]",
                                  "roll_ref_dot[rad/s]", "roll_ref_dot_fil[rad/s]", "pitch_ref_dot[rad/s]", "pitch_ref_dot_fil[rad/s]", "yaw_ref_dot[rad/s]","roll_ref_ddot[rad/s^2]", "roll_ref_ddot_fil[rad/s^2]", "pitch_ref_ddot[rad/s^2]", "pitch_ref_ddot_fil[rad/s^2]", "yaw_ref_ddot[rad/s^2]",
                                  "omega_ref_x[rad/s]", "omega_ref_y[rad/s]", "omega_ref_z[rad/s]", "translational_position_in_I_user_x[m]","translational_position_in_I_user_y[m]","translational_position_in_I_user_z[m]",
                                  "translational_velocity_in_I_user_x[m/s]","translational_velocity_in_I_user_y[m/s]","translational_velocity_in_I_user_z[m/s]",
                                  "translational_acceleration_in_I_user_x[m/s^2]","translational_acceleration_in_I_user_y[m/s^2]","translational_acceleration_in_I_user_z[m/s^2]",
                                  "mu_x[N]", "mu_y[N]","mu_z[N]","U1[N]", "U2[Nm]","U3[Nm]", "U4[Nm]","Thrust1[N]","Thrust2[N]","Thrust3[N]","Thrust4[N]","Thrust5[N]","Thrust6[N]","Thrust7[N]","Thrust8[N]",
                                  "mu_baseline_tran_x[N]", "mu_baseline_tran_y[N]", "mu_baseline_tran_z[N]", 
                                  "mu_adaptive_tran_x[N]", "mu_adaptive_tran_y[N]", "mu_adaptive_tran_z[N]","mu_PD_baseline_tran_x[N]", "mu_PD_baseline_tran_y[N]", "mu_PD_baseline_tran_z[N]",
                                  "Moment_baseline_x[Nm]", "Moment_baseline_y[Nm]", "Moment_baseline_z[Nm]","Moment_adaptive_x[Nm]", "Moment_adaptive_y[Nm]", "Moment_adaptive_z[Nm]",
                                  "Moment_baseline_PI_x[Nm]", "Moment_baseline_PI_y[Nm]", "Moment_baseline_PI_z[Nm]",
                                  "omega_ref_dot_x[rad/s^2]", "omega_ref_dot_y[rad/s^2]", "omega_ref_dot_z[rad/s^2]",
                                  "omega_cmd_dot_x[rad/s^2]", "omega_cmd_dot_y[rad/s^2]", "omega_cmd_dot_z[rad/s^2]",
                                  "omega_cmd_x[rad/s]", "omega_cmd_y[rad/s]", "omega_cmd_z[rad/s]",
                                  "angular_position_dot_x[rad/s]", "angular_position_dot_y[rad/s]", "angular_position_dot_z[rad/s]"]
            
                
                len_header = len(header_csv) +1
                column_serial_number =[]
                for i in range(1,len_header):
                    column_serial_number.append(i)
                csv_writer.writerow(column_serial_number)
                csv_writer.writerow(header_csv)
            
        
        #$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
  
        if (time_now > controller_start_time): #0.1
                      
            # RUNGE KUTTA 4 ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
            
            if controller_type == 'PID':
                # Integrating the ODEs through RK4 for PID controller
                yout = rk4singlestep(controller.PID, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ############################### PID ###############################
                state_phi_ref_diff = yout[0:2]
                state_theta_ref_diff = yout[2:4]
                state_phi_ref_diff_fil = yout[4:6]
                state_theta_ref_diff_fil = yout[6:8]
                integral_position_tracking = yout[8:11]
                integral_angular_error = yout[11:14]
                ###################################################################
        
                
            elif controller_type == 'MRACwithBASELINE':
                # Integrating the ODEs through RK4 for MRAC with Baseline controller
                yout = rk4singlestep(controller.MRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ###################### MRAC WITH BASELINE #########################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                ###################################################################
                
            elif controller_type == 'TwoLayerMRACwithBASELINE':
                # Integrating the ODEs through RK4 for Two-Layer MRAC with Baseline controller
                yout = rk4singlestep(controller.TwoLayerMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ################### 2-LAYER MRAC WITH BASELINE ####################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                e_transient_tran = yout[104:110] # Transient error dynamics translational (Two-layer) 
                K_hat_g_tran = yout[110:128] # \hat{K}_g translational (Two-layer) 
                e_transient_rot = yout[128:131] # Transient error dynamics rotational (Two-layer) 
                K_hat_g_rot = yout[131:140] # \hat{K}_g (rotational)(Two-layer)
                ###################################################################
    
            elif controller_type == 'RobustMRACwithBASELINE':
                # Integrating the ODEs through RK4 for Robust MRAC with Baseline controller
                yout = rk4singlestep(controller.RobustMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ################### ROBUST MRAC WITH BASELINE ######################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                ###################################################################
    
            elif controller_type == 'RobustTwoLayerMRACwithBASELINE':
                # Integrating the ODEs through RK4 for Robust Two-Layer MRAC with Baseline controller
                yout = rk4singlestep(controller.RobustTwoLayerMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ################ ROBUST 2-LAYER MRAC WITH BASELINE ################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                e_transient_tran = yout[104:110] # Transient error dynamics translational (Two-layer) 
                K_hat_g_tran = yout[110:128] # \hat{K}_g translational (Two-layer) 
                e_transient_rot = yout[128:131] # Transient error dynamics rotational (Two-layer) 
                K_hat_g_rot = yout[131:140] # \hat{K}_g (rotational)(Two-layer)
                ###################################################################
                
                
            elif controller_type == 'HybridMRACwithBASELINE':
                
                e_tran_previous = e_tran # e_tran at the previous iteration
                e_rot_previous = e_rot # e_tran at the previous iteration
                
                # Integrating the ODEs through RK4 for Hybrid MRAC with Baseline controller
                yout = rk4singlestep(controller.HybridMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
    
                ###################### MRAC WITH BASELINE #########################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                integral_eQe_tran = yout[104] # Integral of e_tran.T * Q_tran * e_tran
                integral_eQe_rot = yout[105] # Integral of e_rot.T * Q_rot * e_rot
                ###################################################################
                
                print('e_tran', e_tran)
                print('e_tran_previous', e_tran_previous)
                print('e_rot', e_rot)
                print('e_rot_previous', e_rot_previous)
                
                # print('e_tran.T P e_tran', (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item())
                # print('e_tran_previous.T P e_tran_previous', (np.matmul(e_tran_previous.T,np.matmul(P_tran,e_tran_previous))).item())
                # print('e_tran.T Q e_tran', (np.matmul(e_tran.T,np.matmul(Q_tran,e_tran))).item())
                # print('e_tran_previous.T Q e_tran_previous', (np.matmul(e_tran_previous.T,np.matmul(Q_tran,e_tran_previous))).item())
                
                print('s_hybrid_tran: ', s_hybrid_tran)
                print('s_hybrid_rot: ', s_hybrid_rot)
                
                if (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item() > (np.matmul(e_tran_previous.T,np.matmul(P_tran,e_tran_previous))).item():
                    summation_hybrid_P_tran += ((np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item() - (np.matmul(e_tran_previous.T,np.matmul(P_tran,e_tran_previous))).item())
                    print('Condition on P_tran VERIFIED')
                print('summation_hybrid_P_tran', summation_hybrid_P_tran)
                print('integral_eQe_tran', integral_eQe_tran)
                
                if (np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item() > (np.matmul(e_rot_previous.T,np.matmul(P_rot,e_rot_previous))).item():
                    summation_hybrid_P_rot += ((np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item() - (np.matmul(e_rot_previous.T,np.matmul(P_rot,e_rot_previous))).item())
                    print('Condition on P_rot VERIFIED')
                print('summation_hybrid_P_rot', summation_hybrid_P_rot)
                print('integral_eQe_rot', integral_eQe_rot)
                    
                if (flag_first_loop_controller == True): # if it is not the very first loop iteration that the controller does
                
                    if s_hybrid_tran > 1e9 or (s_hybrid_tran > 0 and (time_now - time_reset_trajectory_tran[-1] > tollerance_time_reset_series)):
                        s_hybrid_tran = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING TRAN SERIES')
                        
                    if s_hybrid_rot > 1e9 or (s_hybrid_rot > 0 and (time_now - time_reset_trajectory_rot[-1] > tollerance_time_reset_series)):
                        s_hybrid_rot = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING ROT SERIES')
                
                    if integral_eQe_tran >= summation_hybrid_P_tran: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_tran = [time_reset_trajectory_tran, time_now]
                        print('RESETTING EVENT TRAN, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_tran = find_s(s_hybrid_tran, (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item())
                        print('FOUND s_tran')       
                        # update reference trajectory
                        jump_reference_trajectory_tran = (1 - math.sqrt(((np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item() - series_element(s_hybrid_tran)) / (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item())) * e_tran
                        # jump_reference_trajectory_tran = (1 - math.sqrt(max(0,((np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item() - series_element(s_hybrid_tran)) / (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item()))) * e_tran
                        yout[4:10] = x_ref_tran + jump_reference_trajectory_tran # Update ref traj
    
                        yout[100] = integral_eQe_tran + (e_tran.T * Q_tran * e_tran - e_tran_previous.T * Q_tran * e_tran_previous)
                        
                    if integral_eQe_rot >= summation_hybrid_P_rot: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_rot = [time_reset_trajectory_rot, time_now]
                        print('RESETTING EVENT ROT, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_rot = find_s(s_hybrid_rot, (np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item())
                        print('FOUND s_rot')       
                        # update reference trajectory
                        jump_reference_trajectory_rot = (1 - math.sqrt(((np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item() - series_element(s_hybrid_rot)) / (np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item())) * e_rot
                        yout[58:61] = omega_ref + jump_reference_trajectory_rot # Update ref traj
    
                        yout[101] = integral_eQe_rot + (e_rot.T * Q_rot * e_rot - e_rot_previous.T * Q_rot * e_rot_previous)
                
                # Assigning the new initial conditions for the new RK4 loop iteration
                yin = yout 
                
                flag_first_loop_controller = True
                ###################################################################
                
            elif controller_type == 'HybridTwoLayerMRACwithBASELINE':
                
                epsilon_tran_previous = epsilon_tran # epsilon_tran at the previous iteration
                epsilon_rot_previous = epsilon_rot # epsilon_rot at the previous iteration
                e_transient_tran_previous = e_transient_tran # e_transient_tran at the previous iteration
                e_transient_rot_previous = e_transient_rot # e_transient_rot at the previous iteration
                
                # Integrating the ODEs through RK4 for Hybrid Two-Layer MRAC with Baseline controller
                yout = rk4singlestep(controller.HybridTwoLayerMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                
                ################### 2-LAYER MRAC WITH BASELINE ####################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                e_transient_tran = yout[104:110] # Transient error dynamics translational (Two-layer) 
                K_hat_g_tran = yout[110:128] # \hat{K}_g translational (Two-layer) 
                e_transient_rot = yout[128:131] # Transient error dynamics rotational (Two-layer) 
                K_hat_g_rot = yout[131:140] # \hat{K}_g (rotational)(Two-layer)
                integral_epsQeps_tran = yout[140] # Integral of epsilon_tran.T * Q_tran_2Layer * epsilon_tran
                integral_epsQeps_rot = yout[141] # Integral of epsilon_rot.T * Q_rot_2Layer * epsilon_rot
                integral_etQet_tran = yout[142] # Integral of e_transient_tran.T * Q_tran_2Layer * e_transient_tran
                integral_etQet_rot = yout[143] # Integral of e_transient_rot.T * Q_rot_2Layer * e_transient_rot
                ###################################################################
                
                print('epsilon_tran', epsilon_tran)
                print('epsilon_tran_previous', epsilon_tran_previous)
                print('epsilon_rot', epsilon_rot)
                print('epsilon_rot_previous', epsilon_rot_previous)
                
                print('s_hybrid_tran: ', s_hybrid_tran)
                print('s_hybrid_rot: ', s_hybrid_rot)
                
                if (np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item() > (np.matmul(epsilon_tran_previous.T,np.matmul(P_tran_2Layer,epsilon_tran_previous))).item():
                    summation_hybrid_P_tran += ((np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item() - (np.matmul(epsilon_tran_previous.T,np.matmul(P_tran_2Layer,epsilon_tran_previous))).item())
                    print('Condition on P_tran VERIFIED')
                print('summation_hybrid_P_tran', summation_hybrid_P_tran)
                print('integral_epsQeps_tran', integral_epsQeps_tran)
                
                if (np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item() > (np.matmul(epsilon_rot_previous.T,np.matmul(P_rot_2Layer,epsilon_rot_previous))).item():
                    summation_hybrid_P_rot += ((np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item() - (np.matmul(epsilon_rot_previous.T,np.matmul(P_rot_2Layer,epsilon_rot_previous))).item())
                    print('Condition on P_rot VERIFIED')
                print('summation_hybrid_P_rot', summation_hybrid_P_rot)
                print('integral_epsQeps_rot', integral_epsQeps_rot)
                
            
                if (np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item() > (np.matmul(e_transient_tran_previous.T,np.matmul(P_tran_2Layer,e_transient_tran_previous))).item():
                    summation_hybrid_transient_P_tran += ((np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item() - (np.matmul(e_transient_tran_previous.T,np.matmul(P_tran_2Layer,e_transient_tran_previous))).item())
                    print('Condition on P_tran transient VERIFIED')
                print('summation_hybrid_transient_P_tran', summation_hybrid_transient_P_tran)
                print('integral_etQet_tran', integral_etQet_tran)
                
                if (np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item() > (np.matmul(e_transient_rot_previous.T,np.matmul(P_rot_2Layer,e_transient_rot_previous))).item():
                    summation_hybrid_transient_P_rot += ((np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item() - (np.matmul(e_transient_rot_previous.T,np.matmul(P_rot_2Layer,e_transient_rot_previous))).item())
                    print('Condition on P_rot transient VERIFIED')
                print('summation_hybrid_transient_P_rot', summation_hybrid_transient_P_rot)
                print('integral_etQet_rot', integral_etQet_rot)
                
                    
                if (flag_first_loop_controller == True): # if it is not the very first loop iteration that the controller does
                
                    if s_hybrid_tran > 1e9 or (s_hybrid_tran > 0 and (time_now - time_reset_trajectory_tran[-1] > tollerance_time_reset_series)):
                        s_hybrid_tran = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING TRAN SERIES')
                        
                    if s_hybrid_rot > 1e9 or (s_hybrid_rot > 0 and (time_now - time_reset_trajectory_rot[-1] > tollerance_time_reset_series)):
                        s_hybrid_rot = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING ROT SERIES')
                        
                    if s_hybrid_transient_tran > 1e9 or (s_hybrid_transient_tran > 0 and (time_now - time_reset_trajectory_tran[-1] > tollerance_time_reset_series)):
                        s_hybrid_transient_tran = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING transient TRAN SERIES')
                        
                    if s_hybrid_transient_rot > 1e9 or (s_hybrid_transient_rot > 0 and (time_now - time_reset_trajectory_rot[-1] > tollerance_time_reset_series)):
                        s_hybrid_transient_rot = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING transient ROT SERIES')
                
                
                    if integral_epsQeps_tran >= summation_hybrid_P_tran: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_tran = [time_reset_trajectory_tran, time_now]
                        print('RESETTING EVENT TRAN, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_tran = find_s(s_hybrid_tran, (np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item())
                        print('FOUND s_tran')       
                        # update reference trajectory
                        jump_reference_trajectory_tran = math.sqrt(((np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item() - series_element(s_hybrid_tran)) / (np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item()) * epsilon_tran
                        yout[4:10] = x_tran - e_transient_tran - jump_reference_trajectory_tran # Update ref traj
                        yout[136] = integral_epsQeps_tran + (epsilon_tran.T * Q_tran_2Layer * epsilon_tran - epsilon_tran_previous.T * Q_tran_2Layer * epsilon_tran_previous)
                        
                    if integral_epsQeps_rot >= summation_hybrid_P_rot: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_rot = [time_reset_trajectory_rot, time_now]
                        print('RESETTING EVENT ROT, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_rot = find_s(s_hybrid_rot, (np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item())
                        print('FOUND s_rot')       
                        # update reference trajectory
                        jump_reference_trajectory_rot = math.sqrt(((np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item() - series_element(s_hybrid_rot)) / (np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item()) * epsilon_rot
                        yout[58:61] = angular_velocity - e_transient_rot - jump_reference_trajectory_rot # Update ref traj
                        yout[137] = integral_epsQeps_rot + (epsilon_rot.T * Q_rot_2Layer * epsilon_rot - epsilon_rot_previous.T * Q_rot_2Layer * epsilon_rot_previous)
                        
                    
                    if integral_etQet_tran >= max(summation_hybrid_P_tran, summation_hybrid_transient_P_tran): # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_tran = [time_reset_trajectory_tran, time_now]
                        print('RESETTING EVENT transient TRAN, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_transient_tran = find_s(s_hybrid_transient_tran, (np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item())
                        print('FOUND s_transient_tran')       
                        # update auxillary trajectory
                        yout[100:106] = -math.sqrt(((np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item() - series_element(s_hybrid_transient_tran)) / (np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item()) * e_transient_tran
                        yout[138] = integral_etQet_tran + (e_transient_tran.T * Q_tran_2Layer * e_transient_tran - e_transient_tran_previous.T * Q_tran_2Layer * e_transient_tran_previous)
                        
                    if integral_etQet_rot >= max(summation_hybrid_P_rot, summation_hybrid_transient_P_rot): # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_rot = [time_reset_trajectory_rot, time_now]
                        print('RESETTING EVENT transient ROT, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_transient_rot = find_s(s_hybrid_transient_rot, (np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item())
                        print('FOUND s_rot')       
                        # update auxillary trajectory
                        yout[124:127] = -math.sqrt(((np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item() - series_element(s_hybrid_transient_rot)) / (np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item()) * e_transient_rot
                        yout[139] = integral_etQet_rot + (e_transient_rot.T * Q_rot_2Layer * e_transient_rot - e_transient_rot_previous.T * Q_rot_2Layer * e_transient_rot_previous)
                
                # Assigning the new initial conditions for the new RK4 loop iteration
                yin = yout 
                
                flag_first_loop_controller = True
                ###################################################################
                
            elif controller_type == 'HybridRobustMRACwithBASELINE':
                
                e_tran_previous = e_tran # e_tran at the previous iteration
                e_rot_previous = e_rot # e_tran at the previous iteration
                
                # Integrating the ODEs through RK4 for Robust MRAC with Baseline controller
                yout = rk4singlestep(controller.HybridRobustMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                
                ################### ROBUST MRAC WITH BASELINE ######################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                integral_eQe_tran = yout[104] # Integral of e_tran.T * Q_tran * e_tran
                integral_eQe_rot = yout[105] # Integral of e_rot.T * Q_rot * e_rot
                ###################################################################
                
                print('e_tran', e_tran)
                print('e_tran_previous', e_tran_previous)
                print('e_rot', e_rot)
                print('e_rot_previous', e_rot_previous)
                
                # print('e_tran.T P e_tran', (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item())
                # print('e_tran_previous.T P e_tran_previous', (np.matmul(e_tran_previous.T,np.matmul(P_tran,e_tran_previous))).item())
                # print('e_tran.T Q e_tran', (np.matmul(e_tran.T,np.matmul(Q_tran,e_tran))).item())
                # print('e_tran_previous.T Q e_tran_previous', (np.matmul(e_tran_previous.T,np.matmul(Q_tran,e_tran_previous))).item())
                
                print('s_hybrid_tran: ', s_hybrid_tran)
                print('s_hybrid_rot: ', s_hybrid_rot)
                
                if (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item() > (np.matmul(e_tran_previous.T,np.matmul(P_tran,e_tran_previous))).item():
                    summation_hybrid_P_tran += ((np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item() - (np.matmul(e_tran_previous.T,np.matmul(P_tran,e_tran_previous))).item())
                    print('Condition on P_tran VERIFIED')
                print('summation_hybrid_P_tran', summation_hybrid_P_tran)
                print('integral_eQe_tran', integral_eQe_tran)
                
                if (np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item() > (np.matmul(e_rot_previous.T,np.matmul(P_rot,e_rot_previous))).item():
                    summation_hybrid_P_rot += ((np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item() - (np.matmul(e_rot_previous.T,np.matmul(P_rot,e_rot_previous))).item())
                    print('Condition on P_rot VERIFIED')
                print('summation_hybrid_P_rot', summation_hybrid_P_rot)
                print('integral_eQe_rot', integral_eQe_rot)
                    
                if (flag_first_loop_controller == True): # if it is not the very first loop iteration that the controller does
                
                    if s_hybrid_tran > 1e9 or (s_hybrid_tran > 0 and (time_now - time_reset_trajectory_tran[-1] > tollerance_time_reset_series)):
                        s_hybrid_tran = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING TRAN SERIES')
                        
                    if s_hybrid_rot > 1e9 or (s_hybrid_rot > 0 and (time_now - time_reset_trajectory_rot[-1] > tollerance_time_reset_series)):
                        s_hybrid_rot = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING ROT SERIES')
                
                    if integral_eQe_tran >= summation_hybrid_P_tran: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_tran = [time_reset_trajectory_tran, time_now]
                        print('RESETTING EVENT TRAN, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_tran = find_s(s_hybrid_tran, (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item())
                        print('FOUND s_tran')       
                        # update reference trajectory
                        jump_reference_trajectory_tran = (1 - math.sqrt(((np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item() - series_element(s_hybrid_tran)) / (np.matmul(e_tran.T,np.matmul(P_tran,e_tran))).item())) * e_tran
                        yout[4:10] = x_ref_tran + jump_reference_trajectory_tran # Update ref traj
    
                        yout[100] = integral_eQe_tran + (e_tran.T * Q_tran * e_tran - e_tran_previous.T * Q_tran * e_tran_previous)
                        
                    if integral_eQe_rot >= summation_hybrid_P_rot: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_rot = [time_reset_trajectory_rot, time_now]
                        print('RESETTING EVENT ROT, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_rot = find_s(s_hybrid_rot, (np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item())
                        print('FOUND s_rot')       
                        # update reference trajectory
                        jump_reference_trajectory_rot = (1 - math.sqrt(((np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item() - series_element(s_hybrid_rot)) / (np.matmul(e_rot.T,np.matmul(P_rot,e_rot))).item())) * e_rot
                        yout[58:61] = omega_ref + jump_reference_trajectory_rot # Update ref traj
    
                        yout[101] = integral_eQe_rot + (e_rot.T * Q_rot * e_rot - e_rot_previous.T * Q_rot * e_rot_previous)
                
                # Assigning the new initial conditions for the new RK4 loop iteration
                yin = yout 
                
                flag_first_loop_controller = True
                ###################################################################
                
            elif controller_type == 'HybridRobustTwoLayerMRACwithBASELINE':
                
                epsilon_tran_previous = epsilon_tran # epsilon_tran at the previous iteration
                epsilon_rot_previous = epsilon_rot # epsilon_rot at the previous iteration
                e_transient_tran_previous = e_transient_tran # e_transient_tran at the previous iteration
                e_transient_rot_previous = e_transient_rot # e_transient_rot at the previous iteration
                
                # Integrating the ODEs through RK4 for Robust Two-Layer MRAC with Baseline controller
                yout = rk4singlestep(controller.HybridRobustTwoLayerMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                
                ################ ROBUST 2-LAYER MRAC WITH BASELINE ################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                e_transient_tran = yout[104:110] # Transient error dynamics translational (Two-layer) 
                K_hat_g_tran = yout[110:128] # \hat{K}_g translational (Two-layer) 
                e_transient_rot = yout[128:131] # Transient error dynamics rotational (Two-layer) 
                K_hat_g_rot = yout[131:140] # \hat{K}_g (rotational)(Two-layer)
                integral_epsQeps_tran = yout[140] # Integral of epsilon_tran.T * Q_tran_2Layer * epsilon_tran
                integral_epsQeps_rot = yout[141] # Integral of epsilon_rot.T * Q_rot_2Layer * epsilon_rot
                integral_etQet_tran = yout[142] # Integral of e_transient_tran.T * Q_tran_2Layer * e_transient_tran
                integral_etQet_rot = yout[143] # Integral of e_transient_rot.T * Q_rot_2Layer * e_transient_rot
                ###################################################################
                
                print('epsilon_tran', epsilon_tran)
                print('epsilon_tran_previous', epsilon_tran_previous)
                print('epsilon_rot', epsilon_rot)
                print('epsilon_rot_previous', epsilon_rot_previous)
                
                print('s_hybrid_tran: ', s_hybrid_tran)
                print('s_hybrid_rot: ', s_hybrid_rot)
                
                if (np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item() > (np.matmul(epsilon_tran_previous.T,np.matmul(P_tran_2Layer,epsilon_tran_previous))).item():
                    summation_hybrid_P_tran += ((np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item() - (np.matmul(epsilon_tran_previous.T,np.matmul(P_tran_2Layer,epsilon_tran_previous))).item())
                    print('Condition on P_tran VERIFIED')
                print('summation_hybrid_P_tran', summation_hybrid_P_tran)
                print('integral_epsQeps_tran', integral_epsQeps_tran)
                
                if (np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item() > (np.matmul(epsilon_rot_previous.T,np.matmul(P_rot_2Layer,epsilon_rot_previous))).item():
                    summation_hybrid_P_rot += ((np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item() - (np.matmul(epsilon_rot_previous.T,np.matmul(P_rot_2Layer,epsilon_rot_previous))).item())
                    print('Condition on P_rot VERIFIED')
                print('summation_hybrid_P_rot', summation_hybrid_P_rot)
                print('integral_epsQeps_rot', integral_epsQeps_rot)
                
            
                if (np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item() > (np.matmul(e_transient_tran_previous.T,np.matmul(P_tran_2Layer,e_transient_tran_previous))).item():
                    summation_hybrid_transient_P_tran += ((np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item() - (np.matmul(e_transient_tran_previous.T,np.matmul(P_tran_2Layer,e_transient_tran_previous))).item())
                    print('Condition on P_tran transient VERIFIED')
                print('summation_hybrid_transient_P_tran', summation_hybrid_transient_P_tran)
                print('integral_etQet_tran', integral_etQet_tran)
                
                if (np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item() > (np.matmul(e_transient_rot_previous.T,np.matmul(P_rot_2Layer,e_transient_rot_previous))).item():
                    summation_hybrid_transient_P_rot += ((np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item() - (np.matmul(e_transient_rot_previous.T,np.matmul(P_rot_2Layer,e_transient_rot_previous))).item())
                    print('Condition on P_rot transient VERIFIED')
                print('summation_hybrid_transient_P_rot', summation_hybrid_transient_P_rot)
                print('integral_etQet_rot', integral_etQet_rot)
                
                    
                if (flag_first_loop_controller == True): # if it is not the very first loop iteration that the controller does
                
                    if s_hybrid_tran > 1e9 or (s_hybrid_tran > 0 and (time_now - time_reset_trajectory_tran[-1] > tollerance_time_reset_series)):
                        s_hybrid_tran = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING TRAN SERIES')
                        
                    if s_hybrid_rot > 1e9 or (s_hybrid_rot > 0 and (time_now - time_reset_trajectory_rot[-1] > tollerance_time_reset_series)):
                        s_hybrid_rot = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING ROT SERIES')
                        
                    if s_hybrid_transient_tran > 1e9 or (s_hybrid_transient_tran > 0 and (time_now - time_reset_trajectory_tran[-1] > tollerance_time_reset_series)):
                        s_hybrid_transient_tran = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING transient TRAN SERIES')
                        
                    if s_hybrid_transient_rot > 1e9 or (s_hybrid_transient_rot > 0 and (time_now - time_reset_trajectory_rot[-1] > tollerance_time_reset_series)):
                        s_hybrid_transient_rot = 0 # If enough time passed since the last resetting event, then reset the first element of the series
                        print('RESETTING transient ROT SERIES')
                
                
                    if integral_epsQeps_tran >= summation_hybrid_P_tran: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_tran = [time_reset_trajectory_tran, time_now]
                        print('RESETTING EVENT TRAN, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_tran = find_s(s_hybrid_tran, (np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item())
                        print('FOUND s_tran')       
                        # update reference trajectory
                        jump_reference_trajectory_tran = math.sqrt(((np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item() - series_element(s_hybrid_tran)) / (np.matmul(epsilon_tran.T,np.matmul(P_tran_2Layer,epsilon_tran))).item()) * epsilon_tran
                        yout[4:10] = x_tran - e_transient_tran - jump_reference_trajectory_tran # Update ref traj
                        yout[136] = integral_epsQeps_tran + (epsilon_tran.T * Q_tran_2Layer * epsilon_tran - epsilon_tran_previous.T * Q_tran_2Layer * epsilon_tran_previous)
                        
                    if integral_epsQeps_rot >= summation_hybrid_P_rot: # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_rot = [time_reset_trajectory_rot, time_now]
                        print('RESETTING EVENT ROT, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_rot = find_s(s_hybrid_rot, (np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item())
                        print('FOUND s_rot')       
                        # update reference trajectory
                        jump_reference_trajectory_rot = math.sqrt(((np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item() - series_element(s_hybrid_rot)) / (np.matmul(epsilon_rot.T,np.matmul(P_rot_2Layer,epsilon_rot))).item()) * epsilon_rot
                        yout[58:61] = angular_velocity - e_transient_rot - jump_reference_trajectory_rot # Update ref traj
                        yout[137] = integral_epsQeps_rot + (epsilon_rot.T * Q_rot_2Layer * epsilon_rot - epsilon_rot_previous.T * Q_rot_2Layer * epsilon_rot_previous)
                        
                    
                    if integral_etQet_tran >= max(summation_hybrid_P_tran, summation_hybrid_transient_P_tran): # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_tran = [time_reset_trajectory_tran, time_now]
                        print('RESETTING EVENT transient TRAN, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_transient_tran = find_s(s_hybrid_transient_tran, (np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item())
                        print('FOUND s_transient_tran')       
                        # update auxillary trajectory
                        yout[100:106] = -math.sqrt(((np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item() - series_element(s_hybrid_transient_tran)) / (np.matmul(e_transient_tran.T,np.matmul(P_tran_2Layer,e_transient_tran))).item()) * e_transient_tran
                        yout[138] = integral_etQet_tran + (e_transient_tran.T * Q_tran_2Layer * e_transient_tran - e_transient_tran_previous.T * Q_tran_2Layer * e_transient_tran_previous)
                        
                    if integral_etQet_rot >= max(summation_hybrid_P_rot, summation_hybrid_transient_P_rot): # >=
                        # memorize the time of the event of the reference trajectory update
                        time_reset_trajectory_rot = [time_reset_trajectory_rot, time_now]
                        print('RESETTING EVENT transient ROT, SUCCESFUL')
                            
                        # update s of series
                        s_hybrid_transient_rot = find_s(s_hybrid_transient_rot, (np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item())
                        print('FOUND s_rot')       
                        # update auxillary trajectory
                        yout[124:127] = -math.sqrt(((np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item() - series_element(s_hybrid_transient_rot)) / (np.matmul(e_transient_rot.T,np.matmul(P_rot_2Layer,e_transient_rot))).item()) * e_transient_rot
                        yout[139] = integral_etQet_rot + (e_transient_rot.T * Q_rot_2Layer * e_transient_rot - e_transient_rot_previous.T * Q_rot_2Layer * e_transient_rot_previous)
                
                # Assigning the new initial conditions for the new RK4 loop iteration
                yin = yout 
                
                flag_first_loop_controller = True
                ###################################################################
                
            elif controller_type == 'FunnelMRACwithBASELINE':
                # Integrating the ODEs through RK4 for Funnel MRAC with Baseline controller
                yout = rk4singlestep(controller.FunnelMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ################### FUNNEL MRAC WITH BASELINE #####################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                eta_funnel_tran = yout[104] # eta used to compute the translational dynamics funnel diameter
                eta_funnel_rot = yout[105] # eta used to compute the rotational dynamics funnel diameter
                ###################################################################
                
            elif controller_type == 'FunnelTwoLayerMRACwithBASELINE':
                # Integrating the ODEs through RK4 for Funnel Two-Layer MRAC with Baseline controller
                yout = rk4singlestep(controller.FunnelTwoLayerMRACwithBASELINE, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ################### 2-LAYER MRAC WITH BASELINE ####################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                e_transient_tran = yout[104:110] # Transient error dynamics translational (Two-layer) 
                K_hat_g_tran = yout[110:128] # \hat{K}_g translational (Two-layer) 
                e_transient_rot = yout[128:131] # Transient error dynamics rotational (Two-layer) 
                K_hat_g_rot = yout[131:140] # \hat{K}_g (rotational)(Two-layer)
                eta_funnel_tran = yout[140] # eta used to compute the translational dynamics funnel diameter
                eta_funnel_rot = yout[141] # eta used to compute the rotational dynamics funnel diameter
                ###################################################################
                
            elif controller_type == 'MRACwithBASELINE_SafetyMechanism':
                # Integrating the ODEs through RK4 for MRAC with Baseline controller
                yout = rk4singlestep(controller.MRACwithBASELINE_SafetyMechanism, m_timestep, time_now, yin)
                Y_list = np.append(Y_list,np.resize(yout,(number_of_states,1)), axis=1)
                yin = yout
                
                ###################### MRAC WITH BASELINE #########################
                state_phi_ref_diff = yout[0:2] # State of the differentiator for phi_ref (roll_ref)
                state_theta_ref_diff = yout[2:4] # State of the differentiator for theta_ref (pitch_ref)
                state_phi_ref_diff_fil = yout[4:6] # State of the KF differentiator for phi_ref (roll_ref)
                state_theta_ref_diff_fil = yout[6:8] # State of the KF differentiator for theta_ref (pitch_ref)
                x_ref_tran = yout[8:14] # Reference model state
                integral_position_tracking_ref = yout[14:17] # Integral of ('translational_position_in_I_ref' - 'translational_position_in_I_user')
                K_hat_x_tran = yout[17:35] # \hat{K}_x (translational)
                K_hat_r_tran = yout[35:44] # \hat{K}_r (translational)
                Theta_hat_tran = yout[44:62] # \hat{\Theta} (translational)
                omega_ref = yout[62:65] # Reference model rotational dynamics
                K_hat_x_rot = yout[65:74] # \hat{K}_x (rotational)
                K_hat_r_rot = yout[74:83] # \hat{K}_r (rotational)
                Theta_hat_rot = yout[83:101] # \hat{\Theta} (rotational)
                integral_e_rot = yout[101:104] # Integral of 'e_rot' = (angular_velocity - omega_ref)
                
                integral_angular_error = yout[104:107] # Integral of angular_error = attitude - attitude_ref
                integral_e_omega_ref_cmd = yout[107:110] #Integral of e_omega_ref_cmd = omega_ref - omega_cmd
                
                ###################################################################
            
            # ----------------------------------------------------------------------------------------------------------------------------------------------------------------
            
        
            U = np.array([u1, u2, u3, u4]) # array of control inputs (u1, u2, u3, u4)
    
            # T = np.matmul(U_mat_inv,U) # array of thrust of each motor (T1, T2, T3, T4, T5, T6, T7, T8)
            T = np.matmul(U_mat_inv,U).reshape(8,1) # array of thrust of each motor (T1, T2, T3, T4, T5, T6, T7, T8)
            
            # Thrust saturation
            for i in range(len(T)):
                if T[i][0] < T_MIN:
                    T[i][0] = T_MIN # if some component of the thrust force is smaller than the min thrust that can physically be generated set it to T_MIN
                if T[i][0] > T_MAX:
                    T[i][0] = T_MAX # if some component of the thrust force is greater than the max thrust that can physically be generated set it to T_MAX
    
            # Accounting for motor efficiency
            T = np.array(motor_efficiency_matrix * T)
    
            T_list.append([time_now, T[0][0], T[1][0], T[2][0], T[3][0], T[4][0], T[5][0], T[6][0], T[7][0]])         
            
            # Force applied with the command Accumulate_force()
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[0][0],0),force_1_5_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[1][0],0),force_2_6_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[2][0],0),force_3_7_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[3][0],0),force_4_8_pos,True)
            
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[4][0],0),force_1_5_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[5][0],0),force_2_6_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[6][0],0),force_3_7_pos,True)
            # my_frame.Accumulate_force(chrono.ChVectorD(0,T[7][0],0),force_4_8_pos,True)
            
            ### Motor thrust application position flipped wrt y and x axis (local NED convention)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[2][0],0),force_1_5_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[3][0],0),force_2_6_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[0][0],0),force_3_7_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[1][0],0),force_4_8_pos,True)
            
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[6][0],0),force_1_5_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[7][0],0),force_2_6_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[4][0],0),force_3_7_pos,True)
            my_frame.Accumulate_force(chrono.ChVectorD(0,T[5][0],0),force_4_8_pos,True)
            # ###
            
    
            # Computation of the angular velocities of the propellers
            # omega = np.sqrt((T/2)/K_omega) # I use half T because the thrust computed is not for a single motor but for a couple
            omega = np.sqrt(T/K_omega) # I use T because the thrust computed is for a single motor but not for a couple
            omega_8 = [omega[0], -omega[1], omega[2], -omega[3], -omega[4], omega[5], -omega[6], omega[7]]
            omega_8_list.append([time_now, omega_8[0], omega_8[1], omega_8[2], omega_8[3], omega_8[4], omega_8[5], omega_8[6], omega_8[7]])
        
            torque_1 = chrono.ChVectorD(0,(omega_8[0][0]**2 * K_torque),0) 
            torque_2 = chrono.ChVectorD(0,-(omega_8[1][0]**2 * K_torque),0)
            torque_3 = chrono.ChVectorD(0,(omega_8[2][0]**2 * K_torque),0)
            torque_4 = chrono.ChVectorD(0,-(omega_8[3][0]**2 * K_torque),0)
            torque_5 = chrono.ChVectorD(0,-(omega_8[4][0]**2 * K_torque),0)
            torque_6 = chrono.ChVectorD(0,(omega_8[5][0]**2 * K_torque),0)
            torque_7 = chrono.ChVectorD(0,-(omega_8[6][0]**2 * K_torque),0)
            torque_8 = chrono.ChVectorD(0,(omega_8[7][0]**2 * K_torque),0)  
            torque_list.append([time_now, chvector_to_list(torque_1)[1], chvector_to_list(torque_2)[1], chvector_to_list(torque_3)[1], chvector_to_list(torque_4)[1],
                                chvector_to_list(torque_5)[1], chvector_to_list(torque_6)[1], chvector_to_list(torque_7)[1], chvector_to_list(torque_8)[1]])
            torque_total = torque_1.y + torque_2.y + torque_3.y + torque_4.y + torque_5.y + torque_6.y + torque_7.y + torque_8.y
            
            # Torque applied with the command Accumulate_torque()
            my_frame.Accumulate_torque(torque_1, True)
            my_frame.Accumulate_torque(torque_2, True)
            my_frame.Accumulate_torque(torque_3, True)
            my_frame.Accumulate_torque(torque_4, True)
            my_frame.Accumulate_torque(torque_5, True)
            my_frame.Accumulate_torque(torque_6, True)
            my_frame.Accumulate_torque(torque_7, True)
            my_frame.Accumulate_torque(torque_8, True)
            
            # # Torque applied with the command Accumulate_torque() ALL SET TO ZERO
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
            # my_frame.Accumulate_torque(chrono.ChVectorD(0,0,0), True)
        
            ##############################################################################################################
            
            # DATA Export
            
            if controller_type == 'PID':
                
                ############################## PID ###############################
                DATA_vector = np.zeros((size_DATA,1))
                DATA_vector[0] = time_now
                DATA_vector[1] = simulation_time
                DATA_vector[2:5] = translational_position_in_I
                DATA_vector[5:8] = translational_velocity_in_I
                DATA_vector[8] = roll
                DATA_vector[9] = pitch
                DATA_vector[10] = yaw
                DATA_vector[11:14] = angular_velocity
                DATA_vector[14] = roll_ref
                DATA_vector[15] = pitch_ref
                DATA_vector[16] = yaw_ref
                DATA_vector[17] = roll_ref_dot
                DATA_vector[18] = roll_ref_dot_fil
                DATA_vector[19] = pitch_ref_dot
                DATA_vector[20] = pitch_ref_dot_fil
                DATA_vector[21] = yaw_ref_dot
                DATA_vector[22] = roll_ref_ddot
                DATA_vector[23] = roll_ref_ddot_fil
                DATA_vector[24] = pitch_ref_ddot
                DATA_vector[25] = pitch_ref_ddot_fil 
                DATA_vector[26] = yaw_ref_ddot
                DATA_vector[27:30] = translational_position_in_I_user
                DATA_vector[30:33] = translational_velocity_in_I_user
                DATA_vector[33:36] = translational_acceleration_in_I_user
                DATA_vector[36] = mu_x
                DATA_vector[37] = mu_y
                DATA_vector[38] = mu_z
                DATA_vector[39] = u1
                DATA_vector[40] = u2
                DATA_vector[41] = u3
                DATA_vector[42] = u4
                DATA_vector[43:51] = T.reshape(8,1)
                
                DATA = np.append(DATA,np.resize(DATA_vector,(size_DATA,1)), axis=1)
                ###################################################################
                     
            else: 
                
                ##################### MRAC WITH BASELINE #########################
                DATA_vector = np.zeros((size_DATA,1))
                DATA_vector[0] = time_now
                DATA_vector[1] = simulation_time
                DATA_vector[2:5] = translational_position_in_I
                DATA_vector[5:8] = translational_velocity_in_I
                DATA_vector[8] = roll
                DATA_vector[9] = pitch
                DATA_vector[10] = yaw
                DATA_vector[11:14] = angular_velocity
                DATA_vector[14:20] = x_ref_tran 
                DATA_vector[20] = roll_ref
                DATA_vector[21] = pitch_ref
                DATA_vector[22] = yaw_ref
                DATA_vector[23] = roll_ref_dot
                DATA_vector[24] = roll_ref_dot_fil
                DATA_vector[25] = pitch_ref_dot
                DATA_vector[26] = pitch_ref_dot_fil
                DATA_vector[27] = yaw_ref_dot
                DATA_vector[28] = roll_ref_ddot
                DATA_vector[29] = roll_ref_ddot_fil
                DATA_vector[30] = pitch_ref_ddot
                DATA_vector[31] = pitch_ref_ddot_fil 
                DATA_vector[32] = yaw_ref_ddot
                DATA_vector[33:36] = omega_ref
                DATA_vector[36:39] = translational_position_in_I_user
                DATA_vector[39:42] = translational_velocity_in_I_user
                DATA_vector[42:45] = translational_acceleration_in_I_user
                DATA_vector[45] = mu_x
                DATA_vector[46] = mu_y
                DATA_vector[47] = mu_z
                DATA_vector[48] = u1
                DATA_vector[49] = u2
                DATA_vector[50] = u3
                DATA_vector[51] = u4
                DATA_vector[52:60] = T.reshape(8,1)
                DATA_vector[60:63] = mu_baseline_tran
                DATA_vector[63:66] = mu_adaptive_tran
                DATA_vector[66:69] = mu_PD_baseline_tran
                DATA_vector[69:72] = Moment_baseline
                DATA_vector[72:75] = Moment_adaptive
                DATA_vector[75:78] = Moment_baseline_PI
                
                # DATA_vector[74:77] = omega_ref_dot
                # DATA_vector[77:80] = omega_cmd_dot
                # DATA_vector[80:83] = omega_cmd
                # DATA_vector[83:86] = angular_position_dot
    
                DATA = np.append(DATA,np.resize(DATA_vector,(size_DATA,1)), axis=1)
                ###################################################################
    
            # Motors' rotation direction
            # Motor 1: CCW
            # Motor 2: CW
            # Motor 3: CCW
            # Motor 4: CW
            # Motor 5: CW
            # Motor 6: CCW       
            # Motor 7: CW
            # Motor 8: CCW
            
            # If the controller parameters go beyond 10^6, break the simulation
            if Wrapper_execution == True:
                if abs(u1)>(10**6) or abs(u2)>(10**6) or abs(u3)>(10**6) or abs(u4)>(10**6):
                    with open(csv_file_path_abnormalities, mode='a', newline='') as csv_file_wrapper_ab:
                        csv_writer = csv.writer(csv_file_wrapper_ab)
                        #csv_writer.writerow(["Time","Sum", "Average","Product","Maximum","Minimum"])
                        csv_writer.writerow([my_ball_density])  
                    break
            
            # Setting the propeller rotational velocities (all angular velocities are divided by 10)
            link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_8[0][0]/10))
            link_motor2.SetMotorFunction(chrono.ChFunction_Const(omega_8[1][0]/10))
            link_motor3.SetMotorFunction(chrono.ChFunction_Const(omega_8[2][0]/10))
            link_motor4.SetMotorFunction(chrono.ChFunction_Const(omega_8[3][0]/10))
            link_motor5.SetMotorFunction(chrono.ChFunction_Const(omega_8[4][0]/10))
            link_motor6.SetMotorFunction(chrono.ChFunction_Const(omega_8[5][0]/10))
            link_motor7.SetMotorFunction(chrono.ChFunction_Const(omega_8[6][0]/10))
            link_motor8.SetMotorFunction(chrono.ChFunction_Const(omega_8[7][0]/10))
            
            # link_motor1.SetSpeedFunction(chrono.ChFunction_Const(omega_8[0]))
            # omega_fun.Set_yconst(omega_8[0])
            # link_motor1.SetMotorFunction(chrono.ChFunction_Const(omega_fun))
        
        # # Payload Dropping
        # time_payloadDropping = 4 # 7AIAA, 11 
        # if (time_now > time_payloadDropping): # 5
        #     my_ball1.SetCollide(False)
        #     my_ball2.SetCollide(False)
            
        # if (time_now > (time_payloadDropping + 0.15)): # 5.15
        #     my_ball1.SetCollide(True)
        #     my_ball2.SetCollide(True)
            
        # Motor Failure#!!!
        # if (time_now > 2.5): # 4AIAA
        #     motor_efficiency_matrix = np.matrix(np.diag([1, 1, 0, 1, 1, 1, 0.3, 1]))
            
        # if (time_now > 1):
        #     maximumRollAngle = math.radians(25) # [rad] 25 - 32
        #     maximumPitchAngle = math.radians(25) # [rad] 25 - 32
    
    
    #========================================================================================================================================
    # # Dropping multiple balls one after the other
    #     collision_states = [True] * 10
    
    #     for i in range(0,10):
    #         variable_name = f'my_ball3_{i}'  # Get the variable name of the current ball
    #         if i>0:
    #             variable_name_previous = f'my_ball3_{i-1}'  # Get the variable name of the current ball
        
    #         if variable_name in globals():
    #             current_ball = globals()[variable_name]
    #         if i>0:
    #             if variable_name_previous in globals():
    #                 previous_ball = globals()[variable_name_previous]
        
    #         # Toggle collision state if the time condition is met
    #         if time_now > 5.0 + i * 0.05:
    #             collision_states[i] = False
    #             # if i>0:
    #             #     collision_states[i-1] = True
            
    #         # Set the collision state based on the flag
    #         current_ball.SetCollide(collision_states[i])
    #         if i>0:
    #             previous_ball.SetCollide(collision_states[i-1])
#========================================================================================================================================
    # --------------------------------------------------  
        
        
        # Print data to Console -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        print ('\nSimulation time: ', time_now)
        
        print_cosole_flag = False
        if (print_cosole_flag):
    
          # print('omega_ref_dot: ', '%.4f'%omega_ref_dot[0], '%.4f'%omega_ref_dot[1], '%.4f'%omega_ref_dot[2])
          # print('omega_ref: ', '%.4f'%omega_ref[0], '%.4f'%omega_ref[1], '%.4f'%omega_ref[2])
          # print('omega_cmd_dot: ', '%.8f'%omega_cmd_dot[0],
          #                          '%.8f'%omega_cmd_dot[1],
          #                          '%.8f'%omega_cmd_dot[2])
          # print('omega_cmd: ', '%.4f'%omega_cmd[0], '%.4f'%omega_cmd[1], '%.4f'%omega_cmd[2])
          # print('Jacobian_matrix_dot: ', Jacobian_matrix_dot)
          # print('Jacobian_matrix: ', Jacobian_matrix)
          # print('integral_angular_error: ', '%.4f'%integral_angular_error[0], '%.4f'%integral_angular_error[1], '%.4f'%integral_angular_error[2])
          print('angular_error: ', '%.4f'%angular_error[0], '%.4f'%angular_error[1], '%.4f'%angular_error[2])
          print('angular_error_dot: ', '%.4f'%angular_error_dot[0], '%.4f'%angular_error_dot[1], '%.4f'%angular_error_dot[2])
          
          
          # print('z - z_ref: ', pos_pixhawk_LOC_to_GLOB_NED.z - z_ref)
          print('Z_onboard: ', '%.4f'%pos_pixhawk_LOC_to_GLOB_NED.z)
          # print('(G_acc - controller_z_output)*mass_total: ', (G_acc + controller_z_output)*mass_total)
          print('Thrust T: ', '%.4f'%T[0], '%.4f'%T[1], '%.4f'%T[2], '%.4f'%T[3], '%.4f'%T[4], '%.4f'%T[5], '%.4f'%T[6], '%.4f'%T[7])
          print('Total thrust: ', '%4f'%np.sum(T))
          print('Total torque around Z_onboard: ', '%.4f'%torque_total)
          # print('Pixhawk Euler 321 angles [rad]: ', chvector_to_list(pixhawk_euler))
          
          print('Pixhawk Euler 321 angles [deg]: ', pixhawk_euler_deg_trunc)
          # print('Pixhawk LOCAL angular velocity [rad/s]: ', Wvel_pixhawk_LOC)
          # print('Pixhawk GLOBAL angular velocity [rad/s]: ', Wvel_pixhawk_GLOB)
          
          
          # print('Pixhawk Euler 321 angles OPPOSITE [deg]: ', pixhawk_euler_opposite_deg_trunc)
          # print('Controllers U1 U2 U3 U4:', ' '.join([f'{u:.4f}' for u in U]))
          print('Controllers U1 U2 U3 U4: ', '%.4f'%U[0], '%.4f'%U[1], '%.4f'%U[2], '%.4f'%U[3])
          
          print('mu: ', '%.4f'%mu_x, '%.4f'%mu_y, '%.4f'%mu_z)
          
          # print ('Roll reference [rad]: ', roll_ref)
          # print ('Pitch reference [rad]: ', pitch_ref)
          # print ('Yaw reference [rad]: ', yaw_ref)
          
          print ('Roll reference [deg]: ', '%.4f'%np.rad2deg(roll_ref))
          print ('Pitch reference [deg]: ', '%.4f'%np.rad2deg(pitch_ref))
          print ('Yaw reference [deg]: ', '%.4f'%np.rad2deg(yaw_ref))
          
          print ('mu_PD_baseline_tran [norm x y z]: ', '%.4f'%LA.norm(mu_PD_baseline_tran), '%.4f'%mu_PD_baseline_tran[0].item(), '%.4f'%mu_PD_baseline_tran[1].item(), '%.4f'%mu_PD_baseline_tran[2].item())
          print ('mu_baseline_tran [norm x y z]: ', '%.4f'%LA.norm(mu_baseline_tran), '%.4f'%mu_baseline_tran[0].item(), '%.4f'%mu_baseline_tran[1].item(), '%.4f'%mu_baseline_tran[2].item())
          print ('mu_adaptive_tran [norm x y z]: ', '%.4f'%LA.norm(mu_adaptive_tran), '%.4f'%mu_adaptive_tran[0].item(), '%.4f'%mu_adaptive_tran[1].item(), '%.4f'%mu_adaptive_tran[2].item())
          print ('Moment_baseline_PI [norm x y z]: ', '%.4f'%LA.norm(Moment_baseline_PI), '%.4f'%Moment_baseline_PI[0].item(), '%.4f'%Moment_baseline_PI[1].item(), '%.4f'%Moment_baseline_PI[2].item())
          print ('Moment_baseline [norm x y z]: ', '%.4f'%LA.norm(Moment_baseline), '%.4f'%Moment_baseline[0].item(), '%.4f'%Moment_baseline[1].item(), '%.4f'%Moment_baseline[2].item())
          print ('Moment_adaptive [norm x y z]: ', '%.4f'%LA.norm(Moment_adaptive), '%.4f'%Moment_adaptive[0].item(), '%.4f'%Moment_adaptive[1].item(), '%.4f'%Moment_adaptive[2].item())
          
          print('Time the simulation is taking: ', '%.4f'%simulation_time)
          
          # print('Accumulated force: ', my_frame.Get_accumulated_force()) 
          # print('Aerodynamic force: ', '%.4f'%aerodynamic_force[0].item(), '%.4f'%aerodynamic_force[1].item(), '%.4f'%aerodynamic_force[2].item())
          
          #$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
          
          # print('Ball 3 Euler 321 angles [deg]: ', ball3_euler_deg_trunc)
          # print('Ball 3 Rotmat: ', chmatrix33_to_list(ball3_rotmat))
          
          # print('omega: ', omega)
          
          # print('Drone Frame Position: ', my_frame_pos)
          # print('Pixhawk Coordinate: ', chcoordsys_to_list(coord_pixhawk_GLOB)[0],'\n') # '\n' prints in a new line
                  
          
          # print('Pixhawk LOCAL Position: ', chvector_to_list(pos_pixhawk_LOC))
          print('Pixhawk GLOBAL Position: ', '%.4f'%chcoordsys_to_list(coord_pixhawk_GLOB)[0][0],
                                             '%.4f'%chcoordsys_to_list(coord_pixhawk_GLOB)[0][1],
                                             '%.4f'%chcoordsys_to_list(coord_pixhawk_GLOB)[0][2])
          # print('Pixhawk GLOBAL Velocity: ', chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0])
          # print('Pixhawk LOCAL  Velocity_T: ', chvector_to_list(vel_pixhawk_LOC_T))
          # print('Pixhawk LOCAL  Velocity: ', chvector_to_list(vel_pixhawk_LOC))
          print('Pixhawk GLOBAL Velocity NORM: ', '%.4f'%LA.norm(np.asarray(chcoordsys_to_list(coord_dt_pixhawk_GLOB)[0])))
          # print('Pixhawk LOCAL Velocity_T NORM: ', LA.norm(np.asarray(chvector_to_list(vel_pixhawk_LOC_T))))
          # print('Pixhawk LOCAL Velocity NORM: ', LA.norm(np.asarray(chvector_to_list(vel_pixhawk_LOC))),'\n')
          
          # print('Pixhawk Acceleration: ', chcoordsys_to_list(coord_dtdt_pixhawk_GLOB)[0])
          # print('Pixhawk Angular Velocity: ', chvector_to_list(Wvel_pixhawk_GLOB))
          # print('Pixhawk Angular Acceleration: ', chvector_to_list(Wacc_pixhawk_GLOB))
          
          # print('Drone Frame Position: ', chvector_to_list(my_frame_pos))
          
          # print('Ball_1 Position: ', my_ball1_pos)
          # print('Ball_1 Position seen from the Box Ref. Sys.: ', my_ball1_pos_box)
          
          # print('Ball_3 GLOBAL Velocity: ', chcoordsys_to_list(my_ball3.GetCoord_dt())[0])
          # print('Ball_3 LOCAL Velocity: ', chvector_to_list(coord_dt_ball3_LOC),'\n')
          # print('Ball_3 Quaternion: ', chcoordsys_to_list(my_ball3.GetCoord())[1],'\n')
          # print('Ball_3 Euler 321 angles: ', chvector_to_list(euler321_fromQ_asChVector(my_ball3.GetCoord().rot)),'\n')
          # print('Ball_3 Euler 123 angles: ', chvector_to_list(my_ball3.GetCoord().rot.Q_to_Euler123()),'\n')
          
          # print('COG Position: ', chvector_to_list(COG_total))
          
          
          # my_ball1_cfr = my_ball1.GetContactForce() # contact force applied to ball 1
          # print('Contact Force Ball_1: ', my_ball1_cfr)
          
          # my_ball2_cfr = my_ball2.GetContactForce()
          # my_ball_cfr_list.append([time_now, chvector_to_list(my_ball1_cfr)[0], chvector_to_list(my_ball1_cfr)[1], chvector_to_list(my_ball1_cfr)[2],chvector_to_list(my_ball2_cfr)[0], chvector_to_list(my_ball2_cfr)[1], chvector_to_list(my_ball2_cfr)[2]])
          # print('Contact Force Ball_2: ', my_ball2_cfr)
          
          # my_box_cfr = my_box.GetContactForce()
          # print('Contact Force Box: ', my_box_cfr)
          
          # my_frame_cfr = my_frame.GetContactForce()
          # print('Contact Force Drone Frame: ', my_box_cfr, '\n')
          
          # my_ball1_ctr = my_ball1.GetContactTorque() # contact torque applied to ball 1
          # print('Contact Torque Ball_1: ', my_ball1_ctr)
          
          # my_ball2_ctr = my_ball2.GetContactTorque()
          # print('Contact Torque Ball_2: ', my_ball2_ctr)
          
          # my_box_ctr = my_box.GetContactTorque()
          # print('Contact Torque Box: ', my_box_ctr)
          
          # my_frame_ctr = my_frame.GetContactTorque()
          # print('Contact Torque Drone Frame: ', my_box_ctr, '\n')
    if Wrapper_execution == True:
        DATA = DATA.T
        with open(csv_file_path, mode='a', newline='') as csv_file_wrapper:
            csv_writer = csv.writer(csv_file_wrapper)
            #csv_writer.writerow(["Time","Sum", "Average","Product","Maximum","Minimum"])
            csv_writer.writerows(DATA)                   
                       

    #%% Plots and Post-processing
    
    # state_pixhawk_GLOB_array = list_to_array(state_pixhawk_GLOB)
    # my_ball_cfr_array = list_to_array(my_ball_cfr_list)
    
    # # Use matplotlib to plot data
    # plt.plot(times, euler, color='red') #plot the data 
    # plt.ylabel('Pitch [rad]') #set the label for y axis
    # plt.xlabel('time [s]') #set the label for x-axis
    # plt.title("Ball3 rotation angle") #set the title of the graph
    # plt.show() #display the graph
    
    # # Use matplotlib to plot data
    # plt.plot(times, my_ball_cfr_array[:,1],'o-', color='red', label='X Contact Force') #plot the data 
    # plt.plot(times, my_ball_cfr_array[:,2],'o-', color='green', label='Y Contact Force') #plot the data 
    # plt.plot(times, my_ball_cfr_array[:,3],'o-', color='blue', label='Z Contact Force') #plot the data 
    # plt.legend()
    # plt.ylabel('Contact Force [N]') #set the label for y axis
    # plt.xlabel('time [s]') #set the label for x-axis
    # plt.title("Ball1 Contact Force") #set the title of the graph
    # plt.show() #display the graph     
    
    # # Use matplotlib to plot data
    # plt.plot(times, state_pixhawk_GLOB_array[:,1], color='red') #plot the data 
    # plt.ylabel('Pixhawk x [m]') #set the label for y axis
    # plt.xlabel('time [s]') #set the label for x-axis
    # plt.title("Pixhawk x position") #set the title of the graph
    # plt.show() #display the graph   
            
    if Wrapper_execution == False:
        # DATA saved in CSV file
        np.savetxt("DATA_" + controller_type + ".csv", 
                    DATA,
                    delimiter =", ",  
                    fmt ='% s')
        
  
  



    
